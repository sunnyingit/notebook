我们知道在 Kafka 中，并不保证消息全局有序，但是可以保证分区有序性，分区与分区之间是无序的。那么如何保证 Kafka 中的消息是有序的呢？ 可以从以下三个方面来入手分析：


## 生产端 Producer

首先 Kafka 的 Producer 端发送消息，如果是不对默认参数进行任何设置且网络没有抖动的情况下，消息是可以一批批的按消息发送的顺序被发送到 Kafka Broker 端。但是一旦有网络波动了，如果重试的话，则消息就可能出现乱序。

因为Producer的发送是需要把数据塞到缓冲区，当缓冲区的数据到达一个阈值后再发送，所以重试发送的部分就会乱序。

所以，要严格保证 Kafka 发消息有序，首先要考虑用同步的方式来发送消息, 两种同步发送的方式如下:

设置消息响应参数 acks = all & max.in.flight.requests.per.connection = 1：发送端将会在一条消息发出后，响应必须满足 acks 设置的参数后，才会发送下一条消息。虽然在使用时还是异步发送的方式，其实底层已经是一条接一条的发送了。

幂等问题：Kafka 1.0 之后的版本，Producer 端引入了幂等特性。设置enable.idempotence = true,  幂等特性可以给消息添加序列号，即每次发送会把序列号递增 1。开启了 Kafka Producer端的幂等特性后，我们就可以通过设置参数max.in.flight.requests.per.connection = 5 「默认值」, 这样当 Kafka 发消息的时候，由于消息有了序列号当发送消息出现错误的时候，Kafka 底层会通过获取服务器端的最近几条日志的序列号和发送端需要重新发送的消息序列号做对比，如果是【连续】的，那么就可以继续发送消息，保证消息顺序。

注意是连续的，并不是要比之前的要大就可以发送。

## 服务端 Broker
Kafka 只保证单分区内的消息是有序的，所以如果要保证业务全局严格有序，就要设置 Topic 为单分区的方式。不过对业务来说一般不需要考虑全局有序的，只需要保证业务中不同类别的消息有序即可。

但是这里有个必须要受到重视的问题，就是当我们对分区 Partition 进行数量改变的时候，由于是简单的 Hash 算法会把以前可能分到相同分区的消息分到别的分区上，这样就不能保证消息顺序了。

就需要在动态变更分区的时候，考虑对业务的影响。有可能需要根据业务和当前分区需求，重新划分消息类别。

## 消费端 Consumer

在 Consumer 端，根据 Kafka 的模型，一个 Topic 下的每个分区只能从属于这个 Topic 的消费者组中的某一个消费者。


当消息被发送分配到同一个 Partition 中，消费者从 Partition 中取出来数据的时候，也一定是有顺序的，没有错乱。

但是消费者可能会有多个线程来并发来消费消息。如果单线程消费数据，吞吐量太低了，而多个线程并发消费的话，顺序可能就乱掉了。

所以正确的做法是在consumer做实现内存队列， 将相同 key 的消息都写入同一个队列，然后对于多个线程，每个线程分别消息一个队列即可保证消息顺序。
