# 基础网络知识体系构建

我们目的是为了学习k8s容器网络。

在学习k8s容器网络之前，我们先问自己一个问题，k8s容器网络需要解决哪些问题，我能想到的有：
1. 容器和宿主的子网如何规划。
2. 宿主机和宿主中的容器怎么相互访问。
3. 宿主中的容器如何访问外网。
4. 宿主机中的多个容器之间怎么相互访问。
5. 不同宿主机之间的容器怎么相互访问。

这5个问题都建立在一个问题的基础上，那就是：“宿主机与宿主机之间是如何相互访问的”。

要想搞清楚宿主机之间是如何访问的，需要的知识储备包括：
1. 5层网络模型。
2. 数据在网络中的传递过程。
3. 相关术语的理解，包括以太网，子网，子网掩码，MAC地址，IP地址。
4. 常用物理网络设备和用途：集线器，交换机，路由器。
5. 常用虚拟网络设备和用途包括：Tun/Tap，Veth，Bridge。
6. 网络协议包括：传输层协议(TCP/UDP)，网络层协议（IP），数据链路层协议(ARP)。
7. NAT的技术理解，包括SNAT和DNAT技术

除了网络原理和专业术语的理解以外，我们还需要掌握网络相关的命令，包括：
1. ip相关命令
2. route路由表相关
3. iptables防火墙相关
5. ping，telnet，tcpdump相关

为什么学习*k8s容器网络*需要这些知识储备呢，因为k8s容器网络都是基于以上技术构建，例如：
1. k8s容器Brigde模式网络使用虚拟Brigde和Veth。
2. K8s容器跨主机网络的Host_Gw模式使用了虚拟网卡和路由表。
3. k8s容器跨主机网络的UDP模式使用了虚拟网卡和Tun/Tap。
4. k8s的Service实现使用了iptables的网络转发功能。

所以，如果想要充分了解k8s容器网络，必须掌握以上基础知识。

我们深入浅出，先从最基础的知识开始，相信看完这个系列后，对K8s一无所知的人也能理解k8s的网络实现原理。

## 五层网络模型
网络模型七层，分别是：
```
   +----------------------------------------------------+
   |                      应用层                         |
   +----------------------------------------------------+
   |                      表示层                         |
   +----------------------------------------------------+
   |                      会话层                         |
   +----------------------------------------------------+
   |                      传输层                         |
   +----------------------------------------------------+
   |                      网络层                         |
   +----------------------------------------------------+
   |                      数据链路层                     |
   +----------------------------------------------------+
   |                      物理层                         |
   +----------------------------------------------------+
```

在互联网的实际应用中，我们只需要关注5层模型，分别是：

1. 应用层：应用层是网络七层协议图的顶层，它提供了应用程序与网络之间的接口。应用层协议包括HTTP、FTP、SMTP等，用于实现不同的应用场景。
2. 传输层：传输层提供了可靠的端到端传输服务。它将数据从会话层接收后进行分段和重组，并提供错误检测和恢复功能。常用的传输层协议包括TCP和UDP。
3. 网络层：网络层负责数据的分组和路由。它将数据从传输层接收后进行分组和封装，并根据目的地址进行路由和转发。常用的网络层协议包括IP和ICMP。
4. 数据链路层：数据链路层负责数据的帧封装和错误检测。它将数据从网络层接收后进行帧封装，并提供错误检测和纠正功能。常用的数据链路层协议包括以太网和WiFi。
5. 物理层：物理层负责数据的物理传输。它将数据从数据链路层接收后进行数字转模拟转换，然后将其传输到物理介质上。常用的物理层协议包括电缆和光纤。

这个模型的意义在于：

1. 分层设计：五层网络模型采用分层设计，使得每一层的功能清晰明确，便于网络的设计、维护和升级。
2. 协议规范：每一层都有自己的协议规范，使得不同厂商的网络设备可以相互协作。比如，在物理层，网络设备需要遵循物理层协议规范，如电气特性、传输介质等。
3. 通信可靠性：五层网络模型通过采用多层协议，可以在网络传输过程中提高数据传输的可靠性，使得数据传输更加稳定和安全。
4. 功能独立性：每一层的功能是相对独立的，可以灵活地进行替换和升级，而不会影响到其他层次的功能和协议。

发送网络数据时，数据的流向是：应用层->传输层->网络层->数据链路层->物理层。
接受网络数据时，数据的流向正好相反，分别是：物理层->数据链路层->网络层->传输层->应用层。

## 物理层

我们先回答一个问题：“两台电脑如何传输数据”。

这个问题的完整答案很复杂，但是最基本的要求是要把两台电脑连起来，可以用光缆、电缆、双绞线、无线电波等方式。

在光缆中，传输的数据可以转化成电信号0/1，传输的速度约等于光速。

物理层就是主要负责将比特流转换成物理信号并传输到通信媒介上，以便将数据从一个设备传输到另一个设备。

## 数据链路层

在一个网络中，可以有很多电脑，表示为hostA, hostB，hostC，hostD...，现在hostA需要把数据传递给HostD，怎么实现呢？

在hostA与hostD使用光缆互联的前提下，问题可以转化为:”hostA怎么能找到hostD呢？"。

如果HostD有一个唯一标识，我们通过这个唯一标识就可以找到hostD了。

hostD的唯一标识就是插在hostD上网卡的MAC地址。

也就是说，hostA知道了hostD的MAC地址就可以向hostD发送消息。

### 网卡MAC地址

主机上必须有一张网卡，才能连接到互联网。

网卡用于接受网络数据，网卡的地址，也就是数据包的发送地址和接收地址，就是所谓的MAC地址。

网卡通常具有一个或多个物理接口，用于连接网络电缆或天线。物理接口可以使用不同的连接器类型，例如RJ45插头（用于有线连接）或天线接头（用于无线连接）。

每块网卡出厂的时候，都有一个全世界独一无二的MAC地址，长度是48个二进制位，通常用12个十六进制数表示，例如 00:1A:4D:5C:38:AB。

除了传输数据外，网卡还可以执行其他任务，例如在传输数据之前对数据进行加密和解密、计算校验和等，一些高级网卡还具有硬件协议栈，用于加速网络协议的处理，从而提高网络性能。

hostA要找到hostD，只需要知道hostD网卡的MAC地址即可。

我们先假设hostA已经知道了hostD的MAC地址，那怎么把数据发生给hostD呢？

有两种情况：
1. hostA和hostD在一个子网中。
2. hostA和hostD不在一个子网中。

我们先假设hostA和hostD在同一个子网中，那hostA会在子网内发送一个ARP广播。

子网内的所有主机都会收到这个广播，收到之后会查看hostA发送的目标MAC地址是否和自己的MAC地址相同，如果相同就处理数据，如果不同，就丢弃数据。

hostA拿到了hostD的MAC地址之后，使用以太网协议，把要传输的数据进行编码，然后再次在子网内广播。

子网内的所有主机也会收到这个广播，使用以太网协议解码接受到的数据，比对MAC地址，如果发现和自己的MAC相同，就处理数据，否则直接丢弃。

这样hostD就接收到了hostA的数据。

那现在有个问题，hostA向hostD发生数据的以太网协议是什么？

### 以太网协议
我们清楚了两台主机之间如何传输数据，数据的传输协议如下：
| 字段 | 大小 | 描述 |
| --- | --- | --- |
| 帧头（Preamble） | 8字节（64位） | 用于同步传输速率和提供帧开始的标识。 |
| 目标地址（Destination Address） | 6字节（48位） | 指示数据包的接收者的MAC地址。 |
| 源地址（Source Address） | 6字节（48位） | 指示数据包的发送者的MAC地址。 |
| 类型（Type） | 2字节（16位） | 指示数据包中实际数据的类型。 |
| 数据（Data） | 46~1500字节 | 实际传输的数据，长度在46~1500字节之间。 |
| 帧尾（FCS） | 4字节（32位） | 用于数据完整性的校验和。 |

其中，每个字段的含义如下：
1. 帧头：用于同步传输速率和提供帧开始的标识。
2. 目标地址：指示数据包的接收者的MAC地址。
3. 源地址：指示数据包的发送者的MAC地址。
4. 类型：指示数据包中实际数据的类型。
5. 数据：实际传输的数据，长度在46~1500字节之间。
6. 帧尾：用于数据完整性的校验和。

需要只要发送ARP广播的数据也是通过以太网协议编码，此时目标地址默认是ff：ff：ff：ff：ff：ff。

### 集线器

想象一下，这样一个问题，如果hostA，hostB，hostC需要相互通信，那么就需要用光缆相互联系在一起，如图：
```
┌────────────────┐
│     hostA      ├────────────────────────┐
└───▲────┬──▲────┘                        │
    │    │  │                   ┌─────────▼─────────┐
    │    │  └───────────────────┤                   │
    │    │                      │        hostC      │
    │    │  ┌───────────────────┤                   │
    │    │  │                   └────────▲──────────┘
┌───┴────▼──▼──────┐                     │
│    hostB         ├─────────────────────┘
└──────────────────┘
```

如果子网里面有100机器呢，每一台都需要和另外99台连在一起，买网线的钱都是一大笔开支。

为了解决这个问题，人类发明了集线器，集线器是个物理设备，用网线和主机相连。

线器有多个端口，每个端口都可以连接到一台主机，这样就避免了主机之间相关互联，一个子网的所有主机都可以连接到集线器上，如图：
```

  +-----------+       +------------+
  |   hostA   |       |    hostB   |
  +----+------+       +-------+----+
       |                      |
       |                      |
       |                      |
       |                      |
       |                      |
       |  +--------------+    |
       +->|     hub      |<---+
       +->|     集线器    |<---+
       |  +--------------+    |
       |                      |
       |                      |
       |                      |
       |                      |
+------+-----+       +------+-----+
|   hostC    |       |    hostD   |
+------------+       +------------+

```

集线器Hub连接hostA，hostB，hostC，hostD。

当hostA通过ARP协议询问hostD的MAC地址时，他会把请求转发给集线器，集线器接受到信号后，它仅仅是无脑将电信号转发到所有接口（广播），不做任何处理，这样集线器连接的所有host都能接受到信号。

目标hostD收到信息后，通过对比自己MAC地址和请求的MAC地址，如果相同则处理请求，如果不是则丢弃。


### 数据链路层没有解决的问题

现在我们知道，两台主机能相互通信的核心是需要知道对方的MAC地址，未解决的问题是：
1. hostA怎么获取hostD的MAC地址。
2. 什么是子网，不在同一个子网的主机如何通信。

## 网络层

我们先回答上的一个问题：什么是子网。

子网是指一个独立的网络，在这个网络中，有多个计算机，也称为主机，所有主机使用相同的网络地址前缀和子网掩码来识别和通信，如图：

                    +---------------+
                    |   公网Internet |
                    +---------------+
                             |
            +----------------+----------------+
            |                |                |
    +---------------+  +---------------+  +---------------+
    |   Subnet A    |  |   Subnet B    |  |   Subnet D    |
    +---------------+  +---------------+  +---------------+
            |                |                |
       +--------+       +--------+       +--------+
       |  HostN |       |  HostN |       |  HostN |
       +--------+       +--------+       +--------+

图中，有三个子网，分别是SubnetA，SubnetB，SubnetC，每个子网内都有N个host。

真实世界中，网络运营商他们各自有自己的网络，大型公司也会构建自己的网络，这些子网络一起构建了整个互联网。

现在的问题是：如何判断两个host主机在属于同一个子网。

### 网络地址和子网掩码

我们知道主机网卡有MAC地址，但是MAC是在网卡出厂后就固定了，不利于网络重新划分，于是我们重新给每个网卡一个32位编号，例如：1000000101010000000000000000001。

你觉得有些不清晰，于是把它分成四个部分，中间用点相连，11000000.10101000.00000000.00000001，你还觉得不清晰，于是把它转换成10进制：192.168.0.1。

192.168.0.1就是IP地址，也叫做网络地址。

MAC地址无法修改，但是网络地址是可以随时修改的，MAC地址和网络地址的关系就像手机和手机号一样。

IP地址又划分为网络ID和主机ID，*如果两台主机的网络ID相同，那么他们就同一个子网中，如果不同就是不同的子网。*

例如，一个常见的子网掩码是255.255.255.0。这个子网掩码用二进制表示为11111111.11111111.11111111.00000000，前面的24位用于表示网络ID，后面的8位用于表示主机ID。

IP地址和子网掩码的按位AND运算可以得到网络ID。

例如，如果有一个IP地址为192.168.1.100，子网掩码为255.255.255.0，那么按位 AND 运算结果为192.168.1.0，这就是该IP地址所在的网络ID。

网络ID相同的IP地址就是在同一个子网中，反之就不在同一子网中。

网络还可以表示为192.168.1.100/24，其中24表示为有24个1组成子网掩码。

这样我们就理解了子网和子网掩码的概念。

务必建立这样的概念：*同一个子网中，任何一台主机发送ARP报文，子网内的所有主机都会接受到数据，最后会通过发送方请求的目标IP地址和自己的IP地址比对，如果相同才处理该报文，否则会丢失*。

### ARP协议

接着回答接着第二个问题：hostA怎么获取hostD的MAC地址。

首先hostA访问hostD，需要知道hostD的IP地址，那问题就变成怎么通过IP地址获取到MAC地址呢，答案就是ARP协议。

ARP（Address Resolution Protocol，地址解析协议）是用于将一个IP地址解析为对应的物理地址（如MAC地址）的协议。
当一个主机需要发送数据到另一个主机时，他只知道目标主机的IP地址，通过ARP协议就可以得到目标主机的MAC地址。

ARP协议提供了一种将IP地址解析为物理地址的机制，*注意，ARP协议只能在子网中发挥作用*。

同时，每个主机都会有一份ARP的缓存，保存了IP和MAC的映射，

|   IP 地址      |   MAC 地址      |   接口名称  |   过期时间   |
|----------------|----------------|------------|--------------|
| 192.168.0.1    | 01:23:45:67:89:ab | eth0       | 2023-03-28   |
| 192.168.0.2    | 01:23:45:67:89:cd | eth1       | 2023-03-27   |
| 192.168.0.3    | 01:23:45:67:89:ef | eth0       | 2023-03-29   |


当一个主机需要向目标主机发送数据时，它首先会在自己的ARP缓存中查找目标主机的IP地址是否已经被解析为对应的物理地址。
如果存在，那么该主机可以直接发送数据，如果不存在，则需要进行ARP请求。
ARP请求是广播的，所有在同一子网中的主机都会收到该请求。当目标主机收到ARP请求时，会将自己的物理地址返回给发送ARP请求的主机。

送ARP请求的主机会将得到的物理地址存储在自己的ARP缓存中，以便下次快速访问。

### 交换机

试想一下，在子网中，集线器每次都将信号广播给所有的主机，而只有一个主机会应答，造成了大量的网络带宽浪费，怎么优化呢？

如果hostA知道了hostB的MAC地址，那只需要数据投递给HostB，不需要广播，但如何实现呢？

这就是人类发明交换机需要解决的问题。

交换机是一个物理设备，他提供了很多接口，主机可以通过光缆连接到交换机上，连接在交换机上的主机构成了一个子网，如图所示：
```

   +-------------+          +---------------+
   | Host1       |          | Host2         |
   +-------+-----+          +----+----------+
           |                     |
           |                     |
           |                     |
           |                     |
         +-v---------+-----+-----v----+
         | Port1     |     | Port2    |
         +-----------+     +----------+
         |          Switch            |
         +-----------+     +----------+
         | Port2     |     | Port4    |
         +-+---------+-----+-----^----+
           ^                     |
           |                     |
+----------+-----+        +------+---------+
| Host3          |        |  Host4         |
+----------------+        +----------------+

```

交换机有端口Port 1、Port 2，Port 3，Port4，分别连接了host1，host2，host3，host4。

Host1和Host2通信过程是这样：
1. Host1 通过判断目标主机Host2的ip，发现host2和自己在同一个网段。
2. Host1会直接把数据提交给Switch交换机。
3. 交换机收到数据后，会查找MAC地址和端口的映射表，看看是否host2的MAC地址已经在表中，如果没有，则在子网内发送广播。
4. host2收到广播后，会把MAC地址返回给Switch，Switch在返回给Host1，同时Switch会记录MAC地址和Port2的映射关系。


因为有缓存的存在，*第二次Host1再次请求Host2时，就不需要广播，直接把数据从Port2发送出去了*。

换机内部维护一张 MAC地址和端口的映射表，记录着每一个 MAC 地址的设备，连接在其哪一个端口上，例如：
| MAC地址      | 端口          |
| ------------ | ------------ |
| 00:11:22:33:44:55 | 1       |
| 00:AA:BB:CC:DD:EE | 2       |
| 11:22:33:44:55:66 | 3       |
| FF:FF:FF:FF:FF:FF | 所有端口  |

交换机相对于集线器，更加智能一点，能定向路由，所以交换机是网络层的设备。

### 路由器

到目前为止，我们基本说清楚了主机在*子网*内的通信原理，如果是不同子网内通信，这个怎么实现？

这就该路由器上场啦。

路由器是一个物理网络设备，有自己的IP和MAC地址，可以动态的给路由的接口配置IP，想象一下，假设一个路由器有两个接口：

1. Eth0配置的IP是192.168.1.0/24
2. Eth1配置的IP是192.168.2.0/24

当路由器收到来自于192.168.1.0/24网络段中主机发起的请求，目标网络ip是192.168.2.1，那他就可以转发到192.168.2.0/24子网中。

这样就实现了跨子网的的通信，如同所示：

```
+------------------+
|  hostA           +------------------------+
|eth0:192.168.1.1/24                        |
|                  |                        |                  +-------------------+
+------------------+              +---------v--------+         | Router            |
                                  |   Hub            |         |eth0:192.168.1.4/24|         +-------------------+
                                  |eth0:192.168.1.3/2+--------->                   |         |  hostC            |
                                  |                  |         |                   <---------+  ip:192.168.2.2/24|
                                  +--------^---------+         |                   |         |                   |
+------------------+                       |                   |eth1:192.168.2.1/24|         +-------------------+
|  hostB           |                       |                   |                   |
|eth0:192.168.1.2/24+----------------------+                   +-------------------+
|                  |
+------------------+
```

hostA和hostC处于不同的子网，他们的的通信过程如下：

1. hostA请求hostD，发现hostD的ip是192.168.2.2，和hostA不是一个子网，此时hostA会查找路由表。
2. hostA查找路由表之后，会使用默认网关转发本次请求，默认网关就是配置的网关Router的ip：192.168.1.4。
3. hostA发现默认网关的ip 192.168.1.4和自己是同一个子网，于是把请求转发给集线器Hub。
4. Hub收到请求会广播发送ARP报文询问Router的MAC地址，于是Router会把MAC返回，最终hostA得到了Route的MAC地址。
5. hostA得到了MAC地址后会把请求转发给Router。
4. Retoure获取到hostA的报文后，发现请求的是192.128.2.1，他会对比路由表的网络段和目标IP地址的网络段，最终使用eth1接口发送数据。
5. eth1配置的IP和目标IP是同一个子网，于是直接发起了ARP请求。
6. 子网中的目标主机hostC会响应本次请求，把MAC地址发给路由器。
7. 路由器最终把hostC的MAC地址返回给hostA，最后hostA就可以和hostD通信了。

这样就是实现了跨子网通信。

真实的网络环境中，可能需要经过很多路由器的转发最终才能找到目标主机。可能是Router1继续把数据投递给Router2，然后Router2把数据投递给Router3...

在上文描述中，我们提到了网关和路由表的术语，可能有些读者不懂，我们下文详细解释一下。


### 网关和路由器

什么是网关，怎么配置网关？

网关是一个逻辑概念，拥有网络数据转发的功能都可以成为网关，在微服务中，我们会有各种各样的网关，只要是能转发数据的设备都可以叫做网关。

路由器可以在不同的子网中转发数据，所以路由器也是一个网关。

在上面的例子中，我们提到了默认网关，hostA会使用默认网关进行数据转发。那hostA怎么配置默认网关呢，windows主机配置过程如下：
1. 打开“控制面板”并选择“网络和共享中心”。
2. 点击“更改适配器设置”。
3. 找到您想要更改默认网关的网络连接，并右键单击它。
4. 选择“属性”。
5. 在“网络”选项卡上，找到“Internet 协议版本 4 (TCP/IPv4)”并双击它。
6. 在“常规”选项卡上，选择“使用下面的默认网关地址”并输入默认网关地址。
7. 点击“确定”以保存更改。

默认网关就是*配置的路由器的IP地址，注意路由器有多个接口，每个接口都有自己的IP，也就是说路由器有多个IP，主机需要配置和自己是同一网段的路由器IP*。

### 路由表

首先需要明确，*不是只有路由器才会有路由表，任何网络设备，当然包括主机都会有路由表*。

当主机发生数据时，第一步要做的事情就是判断目标主机是否和自己在同一个子网内，如果不在，就需要使用路由表进行跨子网转发。一张路由表可能如下:

| 目标网络 | 子网掩码 | 默认网关    | 接口         |
| -------- | -------- | -------- | -------- |
| 0.0.0.0  | 0.0.0.0  | 192.168.1.1 |  eth0  |
| 192.168.1.0 | 255.255.255.0 |192.168.1.1 | eth0 |
| 192.168.2.0 | 255.255.255.0 |192.168.2.1 | eth1 |

1. 目标网络：就是需要转发的网络，也就是目标子网。
2. 子网掩码：用于计算目标子网。
3. 网关：就是路由器
4. 接口：就是把数据发出去的设备，通常就是指网卡，

第一行0.0.0.0表示默认路由，因为它的目标网络和子网掩码都为0.0.0.0，表示所有的IP地址，也就是说当找不到目标网络时，它将所有的流量路由到192.168.1.1默认路由器上。

第二个条目描述了192.168.1.0/24子网，数据包将被转发到192.168.1.1网关上。
第二个条目描述了192.168.2.0/24子网，数据包将被转发到192.168.2.1网关上。

路由表就相当于一份地图，畅想一下，我们是不是可以通过修改路由表，实现动态的对数据进行转发。

### IP网络协议

现在我们搞清楚了跨网的数据传递，是时候了解一下ip报文的协议。IP数据报是IP协议传输的数据单元，其格式如下：

| 字段 | 长度 | 描述 |
| --- | --- | --- |
| 版本（Version） | 4位 | 指示IP协议的版本号，IPv4为4，IPv6为6。 |
| 首部长度（Header Length） | 4位 | 指示IP数据报首部长度，以4字节为单位。 |
| 服务类型（Type of Service） | 8位 | 用于指示IP数据报的优先级和服务质量要求。 |
| 总长度（Total Length） | 16位 | 指示IP数据报的总长度，以字节为单位。 |
| 标识（Identification） | 16位 | 用于标识一个IP数据报的唯一性。 |
| 标志（Flags） | 3位 | 包括标志位和片偏移。 |
| 片偏移（Fragment Offset） | 13位 | 指示分段数据的相对位置。 |
| 生存时间（Time to Live） | 8位 | 指示数据报在网络上可以存在的最长时间。 |
| 协议（Protocol） | 8位 | 指示IP数据报中实际数据的协议类型。 |
| 校验和（Header Checksum） | 16位 | 用于校验IP数据报头部的正确性。 |
| 源IP地址（Source IP Address） | 32位 | 指示数据报的发送者的IP地址。 |
| 目标IP地址（Destination IP Address） | 32位 | 指示数据报的接收者的IP地址。 |
| 选项（Options） | 可变 | 用于传递一些与数据报相关的选项信息。 |
| 数据（Data） | 可变 | 实际传输的数据。 |


由此可以看出，在不同的网络段传递数据时，需要配置源IP地址和目标IP地址。


### 网卡配置

到目前为止，我们理解了网卡，网卡的MAC地址，IP，还有一个问题我们没有解决，那就是网卡如何配置IP地址？

网卡可以绑定IP地址，网卡绑定IP地址可以动态绑定也可以静态绑定。

动态绑定IP地址是指在网络中动态地为计算机分配IP地址，而不是手动为每台计算机分配固定的IP地址。

动态绑定IP地址的原理是基于DHCP协议（Dynamic Host Configuration Protocol），该协议是一个客户端/服务器协议，用于自动分配IP地址、子网掩码、网关和DNS等网络配置信息。

1. 客户端计算机在启动时向网络中的DHCP服务器发送广播请求，以请求网络配置信息。
2. DHCP服务器接收到客户端的广播请求后，向客户端提供IP地址、子网掩码、网关、DNS服务器和其他相关的网络配置信息。
3. 客户端接收到DHCP服务器提供的网络配置信息后，将这些信息应用到其网络接口上，以使其能够与网络中的其他计算机进行通信。
4. DHCP服务器将客户端的网络配置信息保存在其数据库中，以便在客户端的租期到期时自动为其分配新的IP地址。

DNS (Domain Name System) 服务器是一种网络服务，用于将域名转换为 IP 地址。当您在浏览器中输入网址时，浏览器需要将该网址转换为相应的 IP 地址，以便能够与目标服务器进行通信。
DNS 服务器可以被分为多层次的，全球性的系统，其中根 DNS 服务器是最顶层的服务器，它们包含所有顶级域名，例如.com、.org和.net等。

较低级别的 DNS 服务器包含更具体的域名信息，例如很多公司都有自己的DNS服务器，顺便提一句，K8s也有专门的DNS服务器。

## 传输层

在数据链路层和网络层，我们已经搞清楚数据的传递过程，有一些问题没有解决：
1. 数据传输的可靠性保证，比如丢包，乱序等。
2. 数据的传输效率保证。

这些事情就是传输层需要解决的问题。

我们来想这样一个问题，一台电脑可以同时看网页，看电影，连接到的是不同的主机，电脑是如何区别不同主机发过来的数据。

答案是传输层的端口，端口并不是网卡上有个物理接口叫做端口，端口只是一个虚拟概念。

端口是0到65535之间的一个整数，用完了就没得用了。我们经常会用到端口被占用的问题，一个端口只能被一个socket监听。

传输层的port 相当于一个用数字表示的网络包队列名，在一些消息队列中叫topic。

接受网络数据时：网卡是生产者，把包推到port队列中。

发送网络数据时，网卡是消费者，进程是生产者。

传输层的功能，就是建立端口到端口的通信。相比之下，网络层的功能是建立IP到IP的通信。

Unix系统就把主机+端口，叫做套接字（socket）。网络编程主要就是考虑socket相关的知识。

传输层协议有TCP协议和UDP协议，协议具体内容不在本文讨论范围中。


## 网络数据发送过程
```

+-------------+        +----------------+      +-----------------+    +---------------+      +---------+
| 应用层       +--------> 传输层          +------> 网络层           +----> 数据链路层      +------>物理层    |
|             |        |                |      |                 |    |               |      |         |
+-------------+        +----------------+      +-----------------+    +---------------+      +---------+


+-------------+        +----------------+      +-----------------+   +-----------------+     +----------+
| 数据段       |        | TCP头+数据      |      | IP头+数据        |   | 帧头+数据        |     | 电信号    |
|              -------->                +------>                 +--->                 +----->          |
+-------------+        +----------------+      +-----------------+   +-----------------+     +----------+

```

1. 应用程序通过socket套接字发起三次握手后，创建连接。
2. 在传输层，数据会应用传输层的协议打包，如果用TCP协议，会加上TCP Header。
3. 传输层的数据给到网卡后，网卡应用网络层的IP协议对传输层的数据再次打包，会加上IP Header。
4. 传输层的数据给到数据链路层后，会被打包层帧(segment), 会加上Segement Head。
5. 传输层的数据传递给物理层后，通过光缆发送出去。

数据解包的过程刚刚相反:
1. 解析segment的头部获取MAC地址
2. 拿到数据之后，通过IP协议解包获取IP等消息
3. 拿到IP网络层的数据之后通过TCP协议获取端口信息
4. 获取到端口信息后，投递到对应的端口队列

## 虚拟网络设备

常见的物理网络设备包括主机，路由器，交换机，集线器。

再次强调一下，所有的网络设备都有IP，子网掩码，MAC地址，ARP缓存，路由表。

此次之外，还有虚拟网络设备，虚拟网络设备通常是操作系统模拟出来的网络设备，和物理网络设备一样，也有IP，子网掩码，MAC地址，ARP缓冲，路由表。

虚拟网络设备是一种虚拟化技术，用于在计算机上创建虚拟的网络接口和设备。它可以将一台计算机虚拟为多个独立的计算机，并提供多个虚拟网络接口和设备，从而使计算机能够同时连接到多个网络或实现网络功能的分离和隔离。

以下是一些常见的虚拟网络设备：

1. 虚拟交换机（Virtual Switch）：虚拟交换机是一种虚拟网络设备，用于在物理网络上创建多个虚拟网络，从而实现虚拟机之间的通信和隔离。
2. 虚拟网卡（Virtual Network Adapter）：虚拟网卡是一种虚拟网络设备，它可以将虚拟机连接到物理网络或虚拟网络中。每个虚拟机都可以拥有一个或多个虚拟网卡，从而实现虚拟机之间和虚拟机与物理网络之间的通信。
3. 虚拟路由器（Virtual Router）：虚拟路由器是一种虚拟网络设备，用于在虚拟网络中实现路由功能，从而实现不同虚拟网络之间的通信和隔离。
4. 虚拟防火墙（Virtual Firewall）：虚拟防火墙是一种虚拟网络设备，用于保护虚拟网络免受网络攻击和威胁。它可以在虚拟网络中实现防火墙功能，过滤网络流量并保护虚拟机和网络资源的安全。


### 虚拟网桥

虚拟Bridge是操作系统提供的功能，他的功能类似于物理网络交换机，可以配置IP，子网掩码。

它可以通过 MAC 地址学习和转发数据包，并允许虚拟机之间直接通信，从而提高网络性能和安全性。

bridge有多个端口，数据可以从任何端口进来，进来之后从哪个口出去和物理交换机的原理差不多，要看mac地址。

#### bridge常用命令
1. 安装 Bridge 工具：如果系统中没有安装 Bridge 工具，可以使用以下命令安装：
```
sudo apt-get install bridge-utils
```

2. 创建 Bridge：使用以下命令创建一个名为 br0 的 Bridge：
```
sudo brctl addbr br0
```

3. 添加物理接口：将一个或多个物理网络接口添加到 Bridge 中：
```
sudo brctl addif br0 eth0
sudo brctl addif br0 eth1
```

这一步就是让主机的网卡eth0，eth1所在的主机连接到交换机，eth0网卡投递数据时，就会先投递给网桥，然后网桥通过目标机器的MAC地址查找对应的端口，之后在投递目标机器。

4. 要查看网桥连接的设备，您可以使用brctl showmacs命令。这个命令将显示网桥上所有连接设备的MAC地址及其所在的端口。
brctl showmacs <bridge_name>

输出格式如下：
```
bridge name     bridge id               STP enabled     interfaces
br0             8000.001c4215a5c5       no              eth0
                                                        eth1
                                                        eth2
```
在这个示例中，我们查看了一个名为br0的网桥。该网桥连接了三个接口：eth0，eth1和eth2，每个接口都有一个MAC地址，也就是bridge id。
如果您在配置交换机时需要设置STP，可以在交换机上的逻辑接口（例如VLAN）上启用或禁用 STP。

再次说明一下，网桥通过目标主机的MAC地址就可以找到对应的接口，然后投递到指定接口。


5. 配置 Bridge IP 地址：可以使用以下命令为 Bridge 配置 IP 地址和子网掩码：
```
sudo ifconfig br0 192.168.1.1 netmask 255.255.255.0 up
```

当我们ping主机的eth0网卡时，eth0网卡会把数据直接转发给网桥，最终返回的网桥的IP地址，如果网桥没有配置IP地址，那ping不通eth0。


#### 虚拟网桥应用

如果我们对k8s熟悉的话，k8s在部署中，会给所有的宿主机都创建一个docker0的网桥。

这个网桥就是用于容器和宿主之间，同一个宿主中不同容器之间的通信。详细过程后文继续提到。


### 虚拟veth

Veth是一种Linux虚拟网络接口，它是成对出现的虚拟网络设备，可以在它们之间传输数据。

Veth有两个重要的特性：
1. 成对出现
2. 两个网络接口可以相互不受网络namespace的限制通信。

我们先忽略网络namespace的概念，总之只要知道Veth创建的一对虚拟网络接口可以相互通信。

#### veth的相关操作
```
1. 创建一对veth接口的示例命令：
# 创建一个名为veth0的接口，并将其连接到名为ns1的网络命名空间中
IP link add veth0 type veth peer name veth1 netns ns1

# 配置veth0，veth1接口的IP地址和网络掩码
IP addr add 192.168.1.1/24 dev veth0
IP addr add 192.168.1.2/24 dev veth1

# 启用veth0接口
IP link set dev veth0 up
```

eth0和eth1是成对出现，互联在一起，可以把eth0和eth1看做虚拟网卡，他们有网卡的特性，比如IP地址，子网掩码和MAC地址。

veth0虚拟接口的MAC地址是在接口创建时自动分配的，可能如下：
```
veth0 MAC地址： 02:91:6a:bf:8c:6f
veth1 MAC地址： 02:91:6a:bf:8c:70
```

vth0和vth1的连接关系如图：
```

         +------------------------+
         |        其他网络设备      |
         +------------------------+
                    ↑
                    ↓
         +------------------------+
         |        Eth1            |
         +------------------------+
                    ↑
                    ↓
         +------------------------+
         |        Eth0            |
         +------------------------+
                    ↑
                    ↓
         +------------------------+
         |       其他网络设备       |
         |        Namespace       |
         +------------------------+
```
假设主机上创建一个Veth设备，一对虚拟设备分别是：Eth0(192.168.1.1)，Eth1（192.168.1.2）

主机指定从Eth0访问Eth1，例如ping -I Eth0  192.168.1.2（Eth1的ip) 过程如下：

1. 主机先需要得到Eth1的MAC地址。
2. 主机发现192.168.1.2和自己同一个网段，由于指定了Eth0接口就不需要广播了。
3. Eth0收到ARP请求后，判断目标IP和自己的IP不一致，于是数据转发给Eth1。
4. Eth1收到信息后，判断目标IP和自己的一致，则把MAC转发给Eth0，在回传给主机。
5. 主机接受到Eth1的MAC地址后，开始发数据，由于指定了Eth0, 还是会把数据转发给Eth0。
6. Eth0判断判断目标IP和自己的不一致，于是把数据转发给Eth1。
7. Eth1收到信息后，判断目标IP和自己的一致，于是处理数据。

这个过程，如何缓存了ARP MAC地址，则可以省略ARP协议部分的请求过程。

### Veth的使用场景

实现一下，k8s在步骤时，完全可以做到这些：
1. 在每个宿主机器中，我们创建一个网桥brige。
2. 在创建虚拟设备Veth，一个Veth有两个虚拟网卡，一个分配容器的IP，一个连接在宿主机上的网桥上。

这样我们是不是就可以实现了宿主机和容器的通信，后续会详解介绍。


## 小结
1. 我们学习了5层网络模型，也理解了每层模型的功能。
2. 主机之间基于MAC地址传输数据，传输数据之前，需要通过ARP协议把IP地址转化为MAC地址，ARP协议只能在子网内广播，同时网络设备都具备缓存ARP结果的能力，包括网卡，交换机，路由器，虚拟网络设备等。
3. 每个网络设备都有MAC地址，IP，子网掩码，ARP缓冲，路由表等，MAC地址和IP的关系类似于手机和电话号码。
4. 我们学习网络段号，子网掩码，如何判断两个IP是否属于同一网段，在同一网段内直接广播发送，如果是交换机的话无需广播，直接投递指定接口。
5. 我们学习了不同网段需要路由器转发，路由器转发需要路由表支持，路由表配置了目标网络，网关，网络接口。
6. 我们理解了集线器，交换机，路由器，虚拟veth网卡，虚拟网桥等相关设备。
