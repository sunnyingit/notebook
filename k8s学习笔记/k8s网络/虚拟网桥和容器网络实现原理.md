# 虚拟网桥和容器网络实现原理

## 概述

学习docker网络之前，最先需要了解的一个概念是*Network Namespace*。

网络命名空间（network namespace）是Linux内核提供的一种网络虚拟化技术，可以将一组网络接口设备和路由表封装在一个独立的命名空间中，从而使得不同的网络栈可以独立运行，互不干扰。

使用网络命名空间可以在同一物理主机上创建多个虚拟的子网，看过[网络知识体系构建](https://github.com/sunnyingit/notebook/blob/master/k8s%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/k8s%E7%BD%91%E7%BB%9C/%E5%9F%BA%E7%A1%80%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E6%9E%84%E5%BB%BA.md)的文章，我们就会明白不同子网之间是无法直接相互访问的。

在创建容器时，我们可以给容器设置和主机不同的的Network Namespace，这样容器和宿主机之间达到了网络隔离的目标。

当容器和宿主之间网络隔离之后，我们还是需要保证容器和宿主之间能相互访问。

所以，我们需要问一下自己：“当我们在谈论容器网络时，我们到底在谈论什么？”。

总结一下，是这样几点：
1. 容器和宿主的网络如何各自的网段。
1. 宿主机和宿主中的容器怎么相互访问。
2. 宿主中的容器如何访问外网。
3. 宿主机中的多个容器之间怎么相互访问。
4. 不同宿主机之间的容器怎么相互访问。


容器和宿主网络互联，常见的实现方式有：
1. Host模式：在Host模式下，容器与主机共享同一个网络命名空间，即不再为容器创建虚拟网卡，而是直接使用宿主机的网络接口。
2. Bridge模式：这是Docker默认的网络模式。在该模式下，Docker会在主机上创建一个虚拟网桥docker0，容器会连接到这个网桥上，然后通过NAT的方式与主机和其他容器进行通信。
3. None模式：在None模式下，容器没有网络接口，也不会被分配IP地址。通常这种模式用于容器的调试和测试。
4. Overlay模式：这种网络模式可以实现跨主机的容器通信。容器会被连接到一个Overlay网络中，并使用Overlay网络的技术在多个主机之间进行通信。
5. Macvlan模式：这种网络模式允许容器使用宿主机上的物理网卡直接连接到物理网络中，并被分配独立的MAC地址和IP地址。


下面我会详解介绍 Host模式和Bridge模式。


## Host模式
声明直接使用宿主机的子网（–net=host），即：不开启 Network Namespace：

```
docker run –d –net=host --name nginx-host nginx
```

在这种情况下，这个容器启动后，直接监听的就是宿主机的80端口。

容器和宿主使用同一个子网，会不可避免地引入共享网络资源的问题，比如端口冲突，真实环境不建议采用。

## Bridge模式

先回顾一下，我们在[网络知识体系构建](https://github.com/sunnyingit/notebook/blob/master/k8s%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/k8s%E7%BD%91%E7%BB%9C/%E5%9F%BA%E7%A1%80%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E6%9E%84%E5%BB%BA.md)提到过网桥，不熟悉的同学可以复习一下。

简单回顾一下，理解网桥，我们先理解桥：桥是连接河的两岸，相对的，网桥就是连接两个网络设备。

可以把网桥看做虚拟交换机，在*子网内连接两个不同的网络设备*。

网桥有自己的MAC地址，IP，子网掩码，可以给网桥添加多个端口，添加语法可以参考[网络操作和异常排查](https://github.com/sunnyingit/notebook/blob/master/k8s%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/k8s%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E5%92%8C%E5%BC%82%E5%B8%B8%E6%8E%92%E6%9F%A5.md)。

每个端口可以连接一个网络设备，连接到网桥上的网络设备发送数据时，如果目标网络设备的IP在子网内，则会直接投递给网桥，网桥通过MAC和端口的映射关系表，投递给对应的端口，避免广播带来的性能损失。

同时，我们在[网络知识体系构建](https://github.com/sunnyingit/notebook/blob/master/k8s%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/k8s%E7%BD%91%E7%BB%9C/%E5%9F%BA%E7%A1%80%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E6%9E%84%E5%BB%BA.md)提到过Veth虚拟网络设备。

简单回顾一下，Veth是一种Linux虚拟网络接口，它是成对出现的虚拟网络设备。

假设通过Veth技术创建一对虚拟网络设备，Eth0和Eth1,那他们有如下特性：*Eth0和Eth1可以相互通信，不受Network Namespace的限制。*

Veth的相关操作命令可以回顾[网络操作和异常排查](https://github.com/sunnyingit/notebook/blob/master/k8s%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/k8s%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E5%92%8C%E5%BC%82%E5%B8%B8%E6%8E%92%E6%9F%A5.md)。


Docker Bridege模式就是虚拟网桥技术和Veth技术实现：
1. 在宿主中创建一个虚拟网桥Docker0。
2. 使用Veth创建一对虚拟网络设备Eth0和Eth1。
3. Eth0作为容器的虚拟网卡，Eth1和虚拟交换机docker0相连。

如图所示：
```

+-------------------------------------------------------------+
|                 +----------------------+                    |
|  Host      Eth0 |    宿主机物理网卡      |                    |
|                 +----------------------+                    |
|                  ip:10.168.1.3/24                           |
|                                                             |
|                  +---------------------+                    |
|                  |                     |                    |
|           +------+     Docker0         +----------+         |
|           | Eth1 |   宿主虚拟交换机      |  Eth1    |         |
|           +---+--+                     +-----+----+         |
|               |  +---------------------+     |              |
|               |     ip:192.168.1.3/24        |              |
|               |                              |              |
|        +--+---+-----+--+           +----+----+---+---+      |
|        |  | Eth0    |  |           |    | Eth0   |   |      |
|        |  |         |  |           |    +--------+   |      |
|        |  +---------+  |           |    Container2   |      |
|        |  Container1   |           |                 |      |
|        |               |           |                 |      |
|        +---------------+           +-----------------+      |
|        ip:192.168.1.1/24           ip:192.168.1.2/24        |
|                                                             |
+-------------------------------------------------------------+
```
解释一下：

1. 宿主机的物理网卡配置了10.168.1.3/24 网段
2. 宿主机创建了Docker0虚拟交换机。
3. 宿主机创建了两个容器Container1，Container2，并且各自为他们创建了Veth设备，一端在容器，一端在宿主的Docker0上。

在宿主机上创建步骤如下：
1. 创建Docker0虚拟网桥：
```
sudo ip link add name docker0 type bridge
```

2. 设置Docker0网桥的IP地址：
```
sudo ip addr add 172.17.0.1/16 dev docker0
```

3. 启动Docker0网桥：
```
sudo ip link set dev docker0 up
```

4. 创建Veth设备对：
```
sudo ip link add veth0 type veth peer name veth1
```

5. 将veth0设备附加到Docker0网桥上：
```
sudo brctl addif docker0 veth0
```

6. 将veth1设备添加到容器的网络命名空间：
```
sudo ip link set veth1 netns <container-id>
```

在上述命令中，<container-id>应替换为您要将veth1设备添加到的容器的ID。

7. 在容器内启动veth1设备：
```
sudo ip netns exec <container-id> ip link set dev veth1 up
```

8. 分配IP地址给容器内的veth1设备
```
sudo ip netns exec <container-id> ip addr add <IP-address>/<subnet-mask> dev veth1
```

9. 添加宿主的路由规则：
例如要使宿主可以访问子网为192.168.1.0/24，则可以使用以下命令：
```
sudo ip route add 192.168.1.0/24 via <虚拟网桥的IP地址>
```

当然以上步骤Docker在创建容器时会帮我们自动处理完成，我们只需要了解一下原理。


### 容器和宿主机相互访问

1. 宿主机器中，容器如何相互访问，例如在图中Container1如何访问Container2？

+-------------------------------------------------------------+
|                 +----------------------+                    |
|  Host      Eth0 |    宿主机物理网卡      |                    |
|                 +----------------------+                    |
|                  ip:10.168.1.3/24                           |
|                                                             |
|                  +---------------------+                    |
|                  |                     |                    |
|           +------+     Docker0         +----------+         |
|           | Eth1 |   宿主虚拟交换机      |  Eth1    |         |
|           +---+--+                     +-----+----+         |
|               |  +---------------------+     |              |
|               |     ip:192.168.1.3/24        |              |
|               |                              |              |
|        +--+---+-----+--+           +----+----+---+---+      |
|        |  | Eth0    |  |           |    | Eth0   |   |      |
|        |  |         |  |           |    +--------+   |      |
|        |  +---------+  |           |    Container2   |      |
|        |  Container1   |           |                 |      |
|        |               |           |                 |      |
|        +---------------+           +-----------------+      |
|        ip:192.168.1.1/24           ip:192.168.1.2/24        |
|                                                             |
+-------------------------------------------------------------+


1. Container1会发现192.168.1.2和自己处于同一网段，于是直接把数据发给网卡Eth0。
2. Eth0是成对网络设备，所以Eth0发给了插在Docker0上Eth1。
3. Eth1接收到数据后，会转发给Docker0，Docker0是宿主的虚拟网络设备，这样宿主就拿到了Container1请求的数据。
4. 宿主一看目标IP是192.168.1.2，和自己并不是一个网络，于是查询路由表。
5. 宿主一看路由表，发现192.168.1.2网段的数据都由Docker0转发，于是Docker0会发送一个ARP广播。
6. “插”在Docker0上面所有的虚拟设备都收到了ARP请求，包括Eth1，Eth1转发给了Eth0。
7. Container2的Eth0解包后，分析出目标IP地址和自己的一样，于是把MAC地址返回回去。
8. 最终Container1就拿到了Container2的MAC地址，就可以完成通信了。


万变不离其宗，只要我们掌握了[网络知识体系构建](https://github.com/sunnyingit/notebook/blob/master/k8s%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/k8s%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E6%9E%84%E5%BB%BA%E5%AF%BC%E8%AF%BB.md），我们就能很清楚的掌握Docker的网桥模式。


2. 容器如何访问宿主机，例如Container1如何访问Host?

详细过程如下：

1. Container1会发现10.168.1.3和自己是不一样的网段，于是查找路由表，此时会匹配到一条默认路由规则，将数据从Eth0发出。
2. Eth0是成对网络设备，Eth1会接受到数据，会转发给Docker0，Docker0是宿主的虚拟网络设备，这样宿主就拿到了Container1请求的数据。
3. 宿主机器拿到数据之后，分析请求的IP和自己是同一个网段，于是把物理网卡Eth0的MAC地址发回给Container1，这样就实现了访问。


3. 宿主机如何访问容器，例如Host如何访问Container1？
详细过程如下：
1. Host发现目标IP 192.168.1.1和自己不是一个网段，于是查询路由表
2. 最终会匹配到Docker0进行转发
3. Docker0会广播，这样Eth1收到数据，在转发给Eth0，这样就拿到了MAC地址，实现了通信。

Overlay模式是解决跨子网的问题，会在K8s网络模式中详细说明。


## 容器和宿主的网段分配。

到目前为止，我们还没有解决的事情是：Docker是怎么分配虚拟网桥和容器IP的。

在Docker中，创建网桥和容器时，网段号的分配主要有两种方式：默认分配和手动指定。

默认情况下，Docker 使用 172.17.0.0/16 作为默认网段，每创建一个网桥就会从这个网段中分配一个 IP 地址，而每个容器就会从这个网段中分配一个独立的 IP 地址。

这种默认的 IP 地址分配方式适用于大部分场景，但如果多个 Docker 主机在同一物理网络内运行，可能会出现 IP 地址冲突的情况。

为了避免 IP 地址冲突的问题，我们可以手动指定网段号。可以使用 --bip 参数为 Docker 分配一个指定的网段。

例如，指定 Docker 使用 192.168.1.0/24 作为网段号：
```
dockerd --bip=192.168.1.1/24
```

此时，每创建一个网桥就会从 192.168.1.0/24 中分配一个 IP 地址，而每个容器也会从这个网段中分配一个独立的 IP 地址。手动指定网段号可以避免 IP 地址冲突问题，但也需要确保指定的网段没有被其他设备使用。

注意，容器的子网和宿主机的子网是不一样的，如果一样，就变成了共享网络Host模式。


## 总结

1. 我们理解了宿主和容器的网段分配逻辑。
2. 怎么逻辑了Docker网络的Host模式和Brige模式的实现原理。
3. 我们学习了如何创建虚拟设备Veth和虚拟Switch。
