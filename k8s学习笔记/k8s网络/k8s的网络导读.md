# k8s网络导读

学习k8s网络相关的问题之前，我们先问自己一个问题，学习k8s网络我们要解决k8s哪些问题，我能想到的有：
1. 宿主机和宿主中的容器怎么相互访问
2. 宿主中的容器如何访问外网
3. 宿主机中的多个容器之间怎么相互访问
4. 不同宿主机之间的容器怎么相互访问
5. k8s的service服务发现怎么实现
6. k8s中的ingress服务理解

这5个问题都建立在一个问题的基础上，那就是：“宿主机与宿主机之间是如何相互访问的”。

要想搞清楚宿主机之间是如何访问的，需要的知识储备包括：
1. 7层网络模型
2. 数据在网络中的传递过程
3. 相关术语的理解，包括以太网，子网，子网掩码，集线器，交换机，路由器，网关，路由表，防火墙
4. 虚拟网络设备和物理网络设备
5. 虚拟网络设备的理解，包括：tun/tap，veth，网桥。
6. 网络协议包括：传输层协议(TCP/UDP)，网络层协议（IP），数据链路层协议(ARP)

除了网络原理和专业术语的理解以外，我们还需要掌握网络相关的命令，包括：
1. ip 相关命令
2. route 路由表相关
3. iptables 防火墙相关
5. ping，telnet，tcpdump相关


## 七层网络模型

网络七层协议图：
   +----------------------------------------------------+
   |                      应用层                         |
   +----------------------------------------------------+
   |                      表示层                         |
   +----------------------------------------------------+
   |                      会话层                         |
   +----------------------------------------------------+
   |                      传输层                         |
   +----------------------------------------------------+
   |                      网络层                         |
   +----------------------------------------------------+
   |                      数据链路层                     |
   +----------------------------------------------------+
   |                      物理层                         |
   +----------------------------------------------------+
为了便于理解，我们只需要关注5层模型：

应用层：应用层是网络七层协议图的顶层，它提供了应用程序与网络之间的接口。应用层协议包括HTTP、FTP、SMTP等，用于实现不同的应用场景。
传输层：传输层提供了可靠的端到端传输服务。它将数据从会话层接收后进行分段和重组，并提供错误检测和恢复功能。常用的传输层协议包括TCP和UDP。
网络层：网络层负责数据的分组和路由。它将数据从传输层接收后进行分组和封装，并根据目的地址进行路由和转发。常用的网络层协议包括IP和ICMP。
数据链路层：数据链路层负责数据的帧封装和错误检测。它将数据从网络层接收后进行帧封装，并提供错误检测和纠正功能。常用的数据链路层协议包括以太网和WiFi。
物理层：物理层负责数据的物理传输。它将数据从数据链路层接收后进行数字转模拟转换，然后将其传输到物理介质上。常用的物理层协议包括电缆和光纤。


## 物理层

我们从最底层开始学习，便于了解网络传输的本质。

我们先回答一个问题：“两台电脑如何相互访问”。
答案很简单，把电脑连起来，可以用光缆、电缆、双绞线、无线电波等方式。

在光缆中，传输的数据可以转化成电信号0/1，传输的速度约等于光速。

## 数据链路层

在一个网络中，可以有很多电脑，表示为hostA, hostB，hostC，hostD...，现在hostA需要把数据传递给HostD，怎么实现呢？

在hostA与hostD使用光缆互联的前提下，问题可以转化为hostA怎么能找到hostD呢？

这个问题进一步转化为每个主机的网卡是否有一个唯一标识，如果hostD有唯一标识，就可以找到hostD.

答案是有，主机的唯一标识就是主机的MAC地址。

### MAC地址

host主机上都有一个网卡，连接到网上，用于接受网络数据，网卡的地址，也就是数据包的发送地址和接收地址，就是所谓的MAC地址。

每块网卡出厂的时候，都有一个全世界独一无二的MAC地址，长度是48个二进制位，通常用12个十六进制数表示，例如 00:1A:4D:5C:38:AB。

hostA要找到hostD，只需要知道hostD的MAC地址即可。怎么获取目标hostD的MAC地址后文会继续说明。

我们先假设hostA已经知道了hostD的MAC地址，那怎么把数据发生给hostD呢？

有两种情况：
1. hostA和hostD在一个子网中。
2. hostA和hostD不在一个子网中。

我们先假设hostA和hostD在同一个子网中，那hostA发送数据时，会在子网中发一个广播，所有子网内的主机都会收到这个广播，收到之后会查看hostA发送的目标MAC地址是否和自己的MAC地址相同，如果相同就接受数据，如果不同，就丢弃数据。

这就是hostA把数据传输给hostD的原理。

### 以太网协议
我们清楚了两台主机之间如何传输数据，数据的传输协议如下：
| 字段 | 大小 | 描述 |
| --- | --- | --- |
| 帧头（Preamble） | 8字节（64位） | 用于同步传输速率和提供帧开始的标识。 |
| 目标地址（Destination Address） | 6字节（48位） | 指示数据包的接收者的MAC地址。 |
| 源地址（Source Address） | 6字节（48位） | 指示数据包的发送者的MAC地址。 |
| 类型（Type） | 2字节（16位） | 指示数据包中实际数据的类型。 |
| 数据（Data） | 46~1500字节 | 实际传输的数据，长度在46~1500字节之间。 |
| 帧尾（FCS） | 4字节（32位） | 用于数据完整性的校验和。 |


其中，每个字段的含义如下：
帧头：用于同步传输速率和提供帧开始的标识。
目标地址：指示数据包的接收者的MAC地址。
源地址：指示数据包的发送者的MAC地址。
类型：指示数据包中实际数据的类型。
数据：实际传输的数据，长度在46~1500字节之间。
帧尾：用于数据完整性的校验和。

### 遗留问题

现在我们知道，两台主机能相互通信的核心是需要知道对方的MAC地址，遗留的问题是：
1. hostA怎么获取hostD的MAC地址。
2. 什么是子网。
3. 不在同一个子网的主机如何通信。


## 网络层

我们先回答上的一个问题：什么是子网。

子网是指一个独立的网络，在这个网络中，有多个计算机，也称为主机，所有主机使用相同的网络地址前缀和子网掩码来识别和通信，如图：

                    +---------------+
                    |   公网Internet  |
                    +---------------+
                             |
                             | IP路由
                             |
                    +---------------+
                    |     Router    |
                    +---------------+
                             |
                             | 子网划分
                             |
            +----------------+----------------+
            |                |                |
    +---------------+  +---------------+  +---------------+
    |   Subnet A    |  |   Subnet B    |  |   Subnet D    |
    +---------------+  +---------------+  +---------------+
            |                |                |
       +--------+       +--------+       +--------+
       |  HostA |       |  HostB |       |  HostD |
       +--------+       +--------+       +--------+


图中，有三个子网，分别是SubnetA，SubnetB，SubnetC，其中SubnetA中有主机hostA，SubnetB中有主机hostB，SubnetD主机中有hostD。

### 网络地址和子网掩码

我们知道主机网卡有MAC地址，但是MAC是在网卡出厂后就固定了，不利于网络重新划分，于是我们重新给每个网卡一个32位编号，例如：
1000000101010000000000000000001

你觉得有些不清晰，于是把它分成四个部分，中间用点相连，11000000.10101000.00000000.00000001，你还觉得不清晰，于是把它转换成 10 进制：192.168.0.1。

192.168.0.1就是ip地址，也叫做网络地址。

MAC地址无法修改，但是网络地址是可以随时修改的，MAC地址和网络地址的关系就像手机和手机号一样。

IP地址又划分为网络ID和主机ID的技术，如果两台主机的网络ID相同，那么他们就同一个子网中，如果不同就是不同的子网。

例如，一个常见的子网掩码是255.255.255.0。这个子网掩码用二进制表示为11111111.11111111.11111111.00000000，前面的24位用于表示网络ID，后面的8位用于表示主机 ID。

IP 地址和子网掩码的按位 AND 运算可以得到网络 ID。
例如，如果有一个 IP 地址为192.168.1.100，子网掩码为255.255.255.0，那么按位 AND 运算结果为192.168.1.0，这就是该 IP 地址所在的网络 ID。

网络ID相同的ip地址就是在同一个子网中，反之就不在同一子网中。

这样我们就理解了子网和子网掩码的概念。

我们知道，同一个子网中，任何一台主机发送消息，子网内的所有主机都会接受到数据，但只会有一台机器接收数据。
想象一下，互联网只有一个网，那么千亿的网络设备相互发数据就是一个灾难。

真实的互联网是无数子网络共同组成的一个巨型网络，子网通过网络ID来标识。




### ARP协议

接着回答上面的问题，hostA怎么获取hostD的MAC地址。

首先hostA访问hostD，需要知道hostD的IP地址，那问题就变成怎么通过IP地址获取到MAC地址呢，答案就是ARP协议。

ARP（Address Resolution Protocol，地址解析协议）是用于将一个IP地址解析为对应的物理地址（如MAC地址）的协议。当一个主机需要发送数据到另一个主机时，它需要知道目标主机的物理地址，而目标主机的IP地址是已知的。ARP协议提供了一种将IP地址解析为物理地址的机制。

注意，ARP协议只能在子网中发挥作用。

当一个主机需要向目标主机发送数据时，它首先会在自己的ARP缓存中查找目标主机的IP地址是否已经被解析为对应的物理地址。如果存在，那么该主机可以直接发送数据。

如果不存在，则需要进行ARP请求。ARP请求是广播的，所有在同一子网中的主机都会收到该请求。当目标主机收到ARP请求时，会将自己的物理地址返回给发送ARP请求的主机。发送ARP请求的主机会将得到的物理地址存储在自己的ARP缓存中，以便下次快速访问。


### 路由器

我们解决了同一子网中数据的传递，那不同子网中数据怎么传递呢，这就需要路由器了。

路由器是一个物理网络设备，有自己的IP和MAC地址，子网内的host需要和其他子网的机器通信都需要经过路由器。

特别注意的是路由器可能接口，每个接口都有子的IP和MAC地址，如何所示:

                +----------------+
                |  Subnet A      |
                |  192.168.1.0/24|
                +----------------+
                    |
                    |
                    |
                +---------------------+
                |  接口A:192.168.1.0/24|
                |  路由器              |
                |  接口B:192.168.2.0/24|
                +---------------------+
                    |
                    |
                +---------------+
                |  Subnet B     |
                |  192.168.2.0/24
                |_______________|

上图中，路由器有两个接口接口A和接口B，分别连接到了两个不同的子网192.168.1.0/24和192.168.2.0/24。

回到之前的问题，假设hostA和hostD分别在子网SubnetA和SubnetB中，那数据传递过程如下：

1. hostA检查目标hostD的IP地址是否与其位于同一子网中，192.168.1.0/24和192.168.2.0/24不在同一子网中。
2. 目标hostD不在同一子网中，则hostA将数据包发送到其默认网关，也是通过ARP先获取路由器的MAC地址。
3. hostA得到了路由器的MAC地址后，把数据转发给路由器。
4. 路由器拿到hostA传递的数据后，会对比路由表和目标IP地址，并确定应将数据包转发到哪个接口。
5. 路由器接口B把数据转发到子网192.168.2.0/24中，在通过ARP协议广播hostD的IP地址
6. 子网中的目标主机hostD会响应本次请求，把MAC地址发给路由器。
7. 路由器接受到了hostD的MAC地址后把数据投递给hostD，同时会把hostD与MAC地址保存在ARP缓存中。

理解路由器的运作过程之后，我们有几个问题：
1. hostA怎么配置路由器
2. 路由器怎么知道找hostD所在的子网

### 网关和路由器
回答问题：“hostA怎么配置路由器”之前，我们先理解一下什么是网关？

网关是一个逻辑概念，拥有数据转发的功能都可以成为网关，所以在微服务中，我们会有各种各样的网关。

路由器可以在不同的子网中转发数据，所以路由器也是一个网关。

主机怎么配置默认网关呢，用windows配置过程如下：
抱歉，您可能想要使用ASCII字符集描述如何配置Windows的默认网关。这是一个简短的ASCII描述：
1. 打开“控制面板”并选择“网络和共享中心”。
2. 点击“更改适配器设置”。
3. 找到您想要更改默认网关的网络连接，并右键单击它。
4. 选择“属性”。
5. 在“网络”选项卡上，找到“Internet 协议版本 4 (TCP/IPv4)”并双击它。
6. 在“常规”选项卡上，选择“使用下面的默认网关地址”并输入默认网关地址。
7. 点击“确定”以保存更改。

网关地址就是所在网络的路由器地址。

### 路由表和路由器

hostA什么情况下会选择使用路由器转发，什么情况下不选择路由器转发，核心还是转发的目标主机是否在同一个网络中，每个主机都有自己的路由表。

例如hostA的路由表如下:

| 目标网络 | 子网掩码 | 默认网关    | 接口         |
| -------- | -------- | -------- | -------- |
| 0.0.0.0  | 0.0.0.0  | 192.168.1.1 |  eth0  |
| 192.168.2.0 | 255.255.255.0 |192.168.1.1 | eth0 |

第一行条目表示默认路由，因为它的目标网络和子网掩码都为0.0.0.0，表示所有的IP地址，当找不到目标网络时，它将所有的流量路由到192.168.1.1，这个网关可以连接到本地网络或互联网。

第二个条目描述了192.168.2.0网络和它们的子网掩码为255.255.255.0。对于这个网络，数据包将被路由到192.168.1.1，它是eth0接口连接到的下一个路由器或交换机。

hostA查找路由表，发现了目标网络192.168.2.0/24在路由表中，他的网关是192.168.1.1，于是就把数据投递给网关，网关就是上文提到的路由器。

路由器里面的有接口的字段，那接口是什么意思呢？

其实，接口就是网卡，数据需要从hostA投递到路由器，需要hostA的网卡投递数据，所以可以把接口理解为网卡。

### IP网络协议

IP数据报是IP协议传输的数据单元，其格式如下：

| 字段 | 长度 | 描述 |
| --- | --- | --- |
| 版本（Version） | 4位 | 指示IP协议的版本号，IPv4为4，IPv6为6。 |
| 首部长度（Header Length） | 4位 | 指示IP数据报首部长度，以4字节为单位。 |
| 服务类型（Type of Service） | 8位 | 用于指示IP数据报的优先级和服务质量要求。 |
| 总长度（Total Length） | 16位 | 指示IP数据报的总长度，以字节为单位。 |
| 标识（Identification） | 16位 | 用于标识一个IP数据报的唯一性。 |
| 标志（Flags） | 3位 | 包括标志位和片偏移。 |
| 片偏移（Fragment Offset） | 13位 | 指示分段数据的相对位置。 |
| 生存时间（Time to Live） | 8位 | 指示数据报在网络上可以存在的最长时间。 |
| 协议（Protocol） | 8位 | 指示IP数据报中实际数据的协议类型。 |
| 校验和（Header Checksum） | 16位 | 用于校验IP数据报头部的正确性。 |
| 源IP地址（Source IP Address） | 32位 | 指示数据报的发送者的IP地址。 |
| 目标IP地址（Destination IP Address） | 32位 | 指示数据报的接收者的IP地址。 |
| 选项（Options） | 可变 | 用于传递一些与数据报相关的选项信息。 |
| 数据（Data） | 可变 | 实际传输的数据。 |


## 传输层

根据上文我们得知，有了MAC地址和IP地址，我们已经可以在互联网上任意两台主机上建立通信。

数据从源主机的网卡发送到目标主机的网卡上，我们来想这样一个问题，一台电脑可以同时看网页，看电影，连接到的是不同的主机，电脑是如何区别不同主机发过来的数据。

答案是传输层的端口，端口是一个虚拟概念，并不是网卡上有个物理接口叫做端口。

传输层的port 相当于一个用数字表示的网络包队列名，在一些消息队列中叫Topic。

接受网络数据时：网卡是生产者，把包推到port队列中。进程是消费者，持有若干 socket 的 fd，而 socket 绑定 ip 和 port，所以进程通过 socket fd 就可以找到对应的网络包队列。

发送数据时，反之，网卡是消费者，进程是生产者。

传输层的功能，就是建立端口到端口的通信。相比之下，网络层的功能是建立IP到IP的通信。

因此，Unix系统就把主机+端口，叫做"套接字"（socket）。

传输层协议有TCP协议和UDP协议，协议具体内容不在本文讨论范围中。


## 网络数据发送过程
```
+----------------+          +----------------+          +----------------+
|   应用层数据    |          |   传输层数据   |          |    IP数据报    |
+----------------+          +----------------+          +----------------+
          |                         |                          |
+----------------+          +----------------+          +----------------+
|    数据段 1    |     -->     |  TCP头部+DATA |      -->  |   IP头部+DATA |
+----------------+          +----------------+          +----------------+
|    数据段 2    |     -->     |  TCP头部+DATA |      -->  |   IP头部+DATA |
+----------------+          +----------------+          +----------------+
         .                    .                           .            |
         .                    .                           .            |
         .                    .                           .            |
+----------------+          +----------------+          +----------------+
|    数据段 n    |     -->     |   TCP头部    |      -->     |   IP头部    |
+----------------+          +----------------+          +----------------+
                                            |                          |
+-------------------------------------------------------------------------+
|                                 数据链路层                                |
+-------------------------------------------------------------------------+
                    |                          |
        +----------------+                  +----------------+
        |    以太网帧    |                   |    以太网帧    |
        +----------------+                  +----------------+
```

1. 应用程序通过socket套接字发起三次握手后，创建连接。
2. 在传输层，数据会应用传输层的协议打包，比如TCP协议
3. 传输层的数据给到网卡后，网卡应用网络层的IP协议对传输层的数据再次打包
4. 传输层的数据给到数据链路层后，会被打包层帧(segment)
5. 传输层的数据传递给物理层后，通过光缆发送出去。

数据解包的过程刚刚相反:
1. 解析segment的头部获取MAC地址
2. 拿到数据之后，通过IP协议解包获取IP等消息
3. 拿到IP网络层的数据之后通过TCP协议获取端口信息
4. 获取到端口信息后，投递到对应的端口队列

## 物理网络设备和虚拟网络设备

常见的物理网络设备包括路由器，交换机和集线器。

### 路由器
路由器上文已经提到了不在赘述。

需要注意的路由器有路由表和ARP缓冲表。

### 集线器

试想一个问题，在子网中，hostA要和子网内所有的host都通信，那是不是hostA需要多条光缆和子网内所有的host相连？

很显然这不是一个好的解决方案，于是有了集线器。

集线器有多个端口，每个端口都可以连接到一台主机，这样就避免了主机之间相关互联，一个子网的所有主机都可以连接到集线器上，如图：

           +-----------+
           |  Host A   |
           +-----------+
                 |
                 |
                 |
                 |
           +-----------+
           |  Hub      |
           +-----------+
                 |
                 |
                 |
                 |
           +-----------+
           |  Host B   |
           +-----------+

集线器Hub连接了两台主机HostA和HostB。

集线器接受到信号后，它仅仅是无脑将电信号转发到所有接口（广播），不做任何处理，这样集线器连接的所有host都能接受到信号。


### 交换机

试想一下，在子网中，集线器每次都将信号广播给所有的主机也很傻，怎么优化一下呢，如果hostA知道了hostB的MAC地址，那只需要数据投递给HostB就可以了，不需要广播，如何实现呢？

交换机就是做这个用途的。交换机有多个端口，每个端口都可以连接到一台主机

如图所示：
```

          +-----------+
          |  Switch   |
          +-----------+
             |     |     |
       Port 1| Port 2| Port 3
             |     |     |
       +-----+     +-----+
       |                  |
  +----+----+         +----+----+
  |  Host 1 |         |  Host 2 |
  +---------+         +---------+
```

交换机有三个端口（Port 1、Port 2和Port 3），有两个主机（Host 1和Host 2），它们通过交换机进行连接。

交换机内部维护一张 MAC地址和端口的映射表，记录着每一个 MAC 地址的设备，连接在其哪一个端口上，例如：
| MAC地址      | 端口          |
| ------------ | ------------ |
| 00:11:22:33:44:55 | 1           |
| 00:AA:BB:CC:DD:EE | 2           |
| 11:22:33:44:55:66 | 3           |
| FF:FF:FF:FF:FF:FF | 所有端口      |

当host1把数据发送给host2时，首先投递到交换机上，交换机通过查询MAC地址和端口的映射表就可以投递到host2，无需广播。

### 网卡

网卡（Network Interface Card）是一种计算机硬件设备，用于将计算机连接到计算机网络中，以实现网络通信。它通常被安装在计算机的扩展插槽上，或者集成在主板上。网卡可以通过有线或无线方式与网络连接，其主要功能是将数据从计算机发送到网络中，或者将数据从网络中接收到计算机上。

网卡通常具有一个或多个物理接口，用于连接网络电缆或天线。物理接口可以使用不同的连接器类型，例如RJ45插头（用于有线连接）或天线接头（用于无线连接）。网卡还具有一个唯一的硬件地址，称为MAC地址，用于在网络中标识该网卡。

除了传输数据外，网卡还可以执行其他任务，例如在传输数据之前对数据进行加密和解密、计算校验和等。一些高级网卡还具有硬件协议栈，用于加速网络协议的处理，从而提高网络性能。

网卡可以绑定IP地址，网卡绑定IP地址可以动态绑定也可以静态绑定。

动态绑定IP地址是指在网络中动态地为计算机分配IP地址，而不是手动为每台计算机分配固定的IP地址。动态绑定IP地址的原理是基于DHCP协议（Dynamic Host Configuration Protocol），该协议是一个客户端/服务器协议，用于自动分配IP地址、子网掩码、网关和DNS等网络配置信息。

1. 客户端计算机在启动时向网络中的DHCP服务器发送广播请求，以请求网络配置信息。
2. DHCP服务器接收到客户端的广播请求后，向客户端提供IP地址、子网掩码、网关、DNS服务器和其他相关的网络配置信息。
3. 客户端接收到DHCP服务器提供的网络配置信息后，将这些信息应用到其网络接口上，以使其能够与网络中的其他计算机进行通信。
4. DHCP服务器将客户端的网络配置信息保存在其数据库中，以便在客户端的租期到期时自动为其分配新的IP地址。


### 虚拟网络设备
虚拟网络设备是一种虚拟化技术，用于在计算机上创建虚拟的网络接口和设备。

虚拟网络设备是一种虚拟化技术，用于在计算机上创建虚拟的网络接口和设备。它可以将一台计算机虚拟为多个独立的计算机，并提供多个虚拟网络接口和设备，从而使计算机能够同时连接到多个网络或实现网络功能的分离和隔离。

以下是一些常见的虚拟网络设备：

1. 虚拟交换机（Virtual Switch）：虚拟交换机是一种虚拟网络设备，用于在物理网络上创建多个虚拟网络，从而实现虚拟机之间的通信和隔离。
2. 虚拟网卡（Virtual Network Adapter）：虚拟网卡是一种虚拟网络设备，它可以将虚拟机连接到物理网络或虚拟网络中。每个虚拟机都可以拥有一个或多个虚拟网卡，从而实现虚拟机之间和虚拟机与物理网络之间的通信。
3. 虚拟路由器（Virtual Router）：虚拟路由器是一种虚拟网络设备，用于在虚拟网络中实现路由功能，从而实现不同虚拟网络之间的通信和隔离。
4. 虚拟防火墙（Virtual Firewall）：虚拟防火墙是一种虚拟网络设备，用于保护虚拟网络免受网络攻击和威胁。它可以在虚拟网络中实现防火墙功能，过滤网络流量并保护虚拟机和网络资源的安全。


### 虚拟网桥

虚拟Bridge是操作系统提供的功能， 他的功能类似于物理网络交换机，可以配置IP，子网掩码。

它可以通过 MAC 地址学习和转发数据包，并允许虚拟机之间直接通信，从而提高网络性能和安全性。

bridge有多个端口，数据可以从任何端口进来，进来之后从哪个口出去和物理交换机的原理差不多，要看mac地址。

#### bridge常用命令
1. 安装 Bridge 工具：如果系统中没有安装 Bridge 工具，可以使用以下命令安装：
```
sudo apt-get install bridge-utils
```

2. 创建 Bridge：使用以下命令创建一个名为 br0 的 Bridge：
```
sudo brctl addbr br0
```

3. 添加物理接口：将一个或多个物理网络接口添加到 Bridge 中：
```
sudo brctl addif br0 eth0
sudo brctl addif br0 eth1
```

这一步就是让主机的网卡eth0，eth1所在的主机连接到交换机，eth0网卡投递数据时，就会先投递给网桥，然后网桥通过目标机器的MAC地址查找对应的端口，之后在投递目标机器。

4. 要查看网桥连接的设备，您可以使用brctl showmacs命令。这个命令将显示网桥上所有连接设备的MAC地址及其所在的端口。
brctl showmacs <bridge_name>

输出格式如下：
```
bridge name     bridge id               STP enabled     interfaces
br0             8000.001c4215a5c5       no              eth0
                                                        eth1
                                                        eth2
```
在这个示例中，我们查看了一个名为br0的网桥。该网桥连接了三个接口：eth0，eth1和eth2，每个接口都有一个MAC地址，也就是bridge id。
如果您在配置交换机时需要设置STP，可以在交换机上的逻辑接口（例如VLAN）上启用或禁用 STP。

再次说明一下，网桥通过目标主机的MAC地址就可以找到对应的接口，然后投递到指定接口。




5. 配置 Bridge IP 地址：可以使用以下命令为 Bridge 配置 IP 地址和子网掩码：
```
sudo ifconfig br0 192.168.1.1 netmask 255.255.255.0 up
```

当我们ping主机的eth0网卡时，eth0网卡会把数据直接转发给网桥，最终返回的网桥的IP地址，如果网桥没有配置IP地址，那ping不通eth0。


#### 虚拟网桥应用

如果我们对k8s熟悉的话，k8s在部署中，会给所有的宿主主机都创建一个docker0的网桥。这个网桥就是用于容器和宿主之间，同一个宿主中不同容器之间的通信。
详细过程后文继续提到。

到这里我们是不是开始对k8s的网络有一点点感觉呢？


### 虚拟veth

Veth是一种Linux虚拟网络接口，它是成对出现的虚拟网络设备，可以在它们之间传输数据。

Veth有两个重要的特性：
1. 成对出现
2. 两个网络接口可以相互不受网络namespace的限制通信。

我们先忽略网络namespace的概念，总之只要知道Veth创建的一对虚拟网络接口可以相互通信。


#### veth的相关操作
```
1. 创建一对veth接口的示例命令：
# 创建一个名为veth0的接口，并将其连接到名为ns1的网络命名空间中
ip link add veth0 type veth peer name veth1 netns ns1

# 配置veth0，veth1接口的IP地址和网络掩码
ip addr add 192.168.1.1/24 dev veth0
ip addr add 192.168.1.2/24 dev veth1

# 启用veth0接口
ip link set dev veth0 up
```

eth0和eth1是成对出现，互联在一起，可以把eth0和eth1看做虚拟网卡，他们有网卡的特性，比如IP地址，子网掩码和MAC地址。

veth0虚拟接口的MAC地址是在接口创建时自动分配的，可能如下：
```
veth0 MAC地址： 02:91:6a:bf:8c:6f
veth1 MAC地址： 02:91:6a:bf:8c:70
```

vth0和vth1的连接关系如图：

         +------------------------+
         |                        |
         |                        |
         |        其他网络设备      |
         |                        |
         +------------------------+
                    ↑
                    |
                    ↓
         +------------------------+
         |                        |
         |        veth1           |
         |                        |
         +------------------------+
                    ↑
                    |
                    ↓
         +------------------------+
         |                        |
         |        veth0           |
         |                        |
         +------------------------+
                    ↑
                    |
                    ↓
         +------------------------+
         |                        |
         |       其他网络设备       |
         |        Namespace       |
         |                        |
         +------------------------+

在主机上指定eth0网卡，ping -I veth0  192.168.1.2 （eth1的目标地址）过程是：
1. 主机先需要得到eth0的MAC地址。
2. 主机发现eth0是同一个网段，由于指定了eth0接口就不需要广播了，直接对eth0发起ARP请求。
3. eth0收到ARP请求后，判断目标IP和自己的IP不一致，于是数据转发给eth1
4. eth1收到信息后，判断目标IP和自己的一致，则把MAC转发给eth0
5. 主机接受到eth1的MAC地址后，由于指定了eth0, 还是会把数据转发给eth0
6. eth0判断判断目标IP和自己的一致，于是把数据转发给eth1.
7. eth1收到信息后，判断目标IP和自己的一致，则把IP转发给eth0
8. eth0在转发给主机

这个过程，如何缓存了ARP MAC地址，则可以省略ARP协议部分的请求过程。

### Veth的使用场景

实现一下，k8s在步骤时，完全可以做到这些：
1. 在每个宿主机器中，我们创建一个网桥brige。
2. 在创建虚拟设备Veth，一个Veth有两个虚拟网卡，一个分配容器的IP，一个连接在宿主机上的网桥上。

这样我们是不是就可以实现了宿主机和容器的通信，后续会详解介绍。


## 小结
1. 我们学习了5层网络模型，也理解了每层模型负责的任务。
2. 主机之间基于MAC地址传输数据，传输数据之前，需要通过ARP协议把IP地址转化为MAC地址，ARP协议只能在子网内广播，同时网络设备都具备缓存ARP结果的能力，包括网卡，交换机，路由器，虚拟网络设备等。
3. 每个网络设备都有MAC地址，IP，子网掩码，ARP缓冲，路由表等，MAC地址和IP的关系类似于手机和电话号码。
4. 我们学习网络段号，子网掩码，如何判断两个IP是否属于同一网段，在同一网段内直接广播发送，如果是交换机的话无需广播，直接投递指定接口。
5. 我们学习了不同网段需要路由器转发，路由器转发需要路由表支持，路由表配置了目标网络，网关，网络接口。
6. 我们理解了集线器，交换机，路由器，虚拟veth网卡，虚拟网桥等相关设备。
