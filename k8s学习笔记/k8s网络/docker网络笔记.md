# docker网络笔记

## 概述

学习docker网络之前，最先需要了解的一个概念是Network Namespace。

网络命名空间（network namespace）是Linux内核提供的一种网络虚拟化技术，可以将一组网络接口设备和路由表封装在一个独立的命名空间中，从而使得不同的网络栈可以独立运行，互不干扰。每个网络命名空间都拥有自己的IP地址、路由表、网络设备等网络资源，可以独立配置和管理，相互之间不会产生冲突。

使用网络命名空间可以在同一物理主机上创建多个虚拟的网络栈，每个网络栈之间是相互隔离的，相当于在一台物理主机上创建了多个虚拟网络。这种技术广泛应用于容器化技术中，可以为每个容器分配一个独立的网络命名空间，从而实现容器之间的网络隔离和互联。

在创建容器时，我们可以给容器设置独立的Network Namespace，这样容器和宿主机之间达到了网络隔离的目标。

首先，我们需要明白，docker的网络实现到底要做什么事情。

docker的网络实现，是为了保证宿主和容器，容器与容器之间网络互通。

我们通过docker，在宿主机器上可以创建多个容器，每个容器都可以有自己的网络空间。

所有网络空间，就是需要创建这个网络的网段，子网掩码，网关，分配子网里面容器的ip地址。

这些信息分配之后，能保证容器互联，容器和宿主互联，常见的实现方式有：
1. Host模式：在Host模式下，容器与主机共享同一个网络命名空间，即不再为容器创建虚拟网卡，而是直接使用宿主机的网络接口。
2. Bridge模式：这是Docker默认的网络模式。在该模式下，Docker会在主机上创建一个虚拟网桥docker0，容器会连接到这个网桥上，然后通过NAT的方式与主机和其他容器进行通信。
3. None模式：在None模式下，容器没有网络接口，也不会被分配IP地址。通常这种模式用于容器的调试和测试。
4. Overlay模式：这种网络模式可以实现跨主机的容器通信。容器会被连接到一个Overlay网络中，并使用Overlay网络的技术在多个主机之间进行通信。
5. Macvlan模式：这种网络模式允许容器使用宿主机上的物理网卡直接连接到物理网络中，并被分配独立的MAC地址和IP地址。


## Host模式
声明直接使用宿主机的网络栈（–net=host），即：不开启 Network Namespace：

```
docker run –d –net=host --name nginx-host nginx
```

在这种情况下，这个容器启动后，直接监听的就是宿主机的 80 端口。

像这样直接使用宿主机网络栈的方式，虽然可以为容器提供良好的网络性能，但也会不可避免地引入共享网络资源的问题，比如端口冲突，真实环境不建议采用。

## Bridge模式

先回顾一下，我们在[网络知识体系构建](https://github.com/sunnyingit/notebook/blob/master/k8s%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/k8s%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E6%9E%84%E5%BB%BA%E5%AF%BC%E8%AF%BB.md）提到过网桥。

简单回顾一下，所谓网桥，就是虚拟交换机，在子网内的一种虚拟网络射波。

网桥有自己的MAC地址，IP，子网掩码，可以给网桥添加多个端口，添加语法可以参考[网络操作和异常排查](https://github.com/sunnyingit/notebook/blob/master/k8s%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/k8s%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E5%92%8C%E5%BC%82%E5%B8%B8%E6%8E%92%E6%9F%A5.md)。

每个端口可以连接一个网络设备，连接到网桥上的网络设备发送数据时，如果目标host在子网内，则会直接投递给网桥，网桥通过MAC和端口的映射关系表，直接投递给对应的端口。

同时，我们在[网络知识体系构建](https://github.com/sunnyingit/notebook/blob/master/k8s%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/k8s%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E6%9E%84%E5%BB%BA%E5%AF%BC%E8%AF%BB.md）提到过Veth虚拟网络设备。

再次回顾一下。

Veth是一种Linux虚拟网络接口，它是成对出现的虚拟网络设备，可以在它们之间传输数据。

Veth有两个重要的特性：
1. 成对出现
2. 两个网络接口可以相互不受网络namespace的限制通信。

操作命令可以回顾[网络操作和异常排查](https://github.com/sunnyingit/notebook/blob/master/k8s%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/k8s%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E5%92%8C%E5%BC%82%E5%B8%B8%E6%8E%92%E6%9F%A5.md)。


Docker网桥模式就是通过 Linux 内核提供的虚拟网络设备 veth（即虚拟以太网设备）来实现的。
veth 设备是成对出现的，一端在容器内，另一端在宿主机上。
容器内的 veth 设备通常被命名为 eth0，而在宿主机上的 veth 设备则会被 Docker 自动分配一个名称。

创建过程如下：
1. Docker 守护进程启动时，会自动在宿主上创建一个名为 docker0 的网桥，并为该虚拟网桥分配一个 IP 地址，通常为 172.17.0.1/16。
2. 当Docker 容器启动时，Docker 会为每个容器创建一对虚拟网卡，一端做完容器的网卡，另一端连接到 宿主的docker0网桥上。同时配置容器的IP地址，也在172.17.0.1/16网段中


如图所示：


                      +----------------------+
                      |       host1          |
                      |    10.168.0.1/24     |
                      |  +---------------+   |
                      |  |  container2   |   |
                      |  |  eth0:        |   |
                      |  |  172.17.0.1/24|   |
                      |  +---------------+   |
                      |         |            |
                      |  +---------------+   |
                      |  |  docker0      |
                      |  |  172.17.0.2/24|   |
                      |  +---------------+   |
                      |         |            |
                      |  +---------------+   |
                      |  |  container1   |   |
                      |  |  eth0:        |   |
                      |  |  172.17.0.3/24|   |
                      |  +---------------+   |
                      +----------------------+


注意，网桥是虚拟交换机，只能在子网内的转发数据，所以docker0, container1, container2的ip地址必须在同一个网段内。

### 虚拟网桥和容器IP的分配
问题来了，docker是怎么分配虚拟网桥和容器IP的。

在 Docker 中，创建网桥和容器时，网段号的分配主要有两种方式：默认分配和手动指定。

默认情况下，Docker 使用 172.17.0.0/16 作为默认网段，每创建一个网桥就会从这个网段中分配一个 IP 地址，而每个容器就会从这个网段中分配一个独立的 IP 地址。这种默认的 IP 地址分配方式适用于大部分场景，但如果多个 Docker 主机在同一物理网络内运行，可能会出现 IP 地址冲突的情况。

为了避免 IP 地址冲突的问题，我们可以手动指定网段号。可以使用 --bip 参数为 Docker 分配一个指定的网段。
例如，指定 Docker 使用 192.168.1.0/24 作为网段号：
```
dockerd --bip=192.168.1.1/24
```

此时，每创建一个网桥就会从 192.168.1.0/24 中分配一个 IP 地址，而每个容器也会从这个网段中分配一个独立的 IP 地址。手动指定网段号可以避免 IP 地址冲突问题，但也需要确保指定的网段没有被其他设备使用。

注意，容器的子网和宿主机的子网是不一样的，如果一样，就变成了共享网络Host模式。


### 宿主机器中，容器如何相互访问
假设在容器container1上ping 172.17.0.1/24，过程如下：

1. container1会发现172.17.0.1和自己处于同一网段，于是就会把数据转发给默认网关，由eth0接口发出。
2. eth0是成对网络设备，所以eth0发给了插在docker0上另个设备。
3. 另一个设备接收到数据后，会转发给docker0，docker0在宿主机器上。
4. 宿主查看路由表，会使用docker0接口转发数据。
5. docker0是交换机，docker0会广播ARP协议，插在docker0所有的网络设备都收到广播，于是container2的插在docker0的一端收到请求。
6. 他无脑转发给container2的eth0。
7. eth0解包后，分析出目标IP地址和他的一样，于是把MAC地址返回回去。
8. 这样container1就拿到了container2的MAC地址，container1的eth0就可以将数据包发出去

当container1发送数据时，会查看路由表，会得到这样的消息：

```
$ route
Kernel IP routing table
Destination  Gateway    Genmask        Flags   Metric Ref   Use     Iface
default      172.17.0.1  0.0.0.0        UG      0      0     0      eth0
172.17.0.0    0.0.0.0   255.255.255.0  U       0      0     0      eth0
```
也就是说，发送的IP地址是172.17.0.1，匹配了第二条规则，由eth0转发， 而这个 Veth Pair 设备的另一端，则在宿主机网桥上。

当宿主机通过docker0接收到接受到数据后，查询路由表，会得到这样的消息：
```
➜  ~ route
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
default         _gateway        0.0.0.0         UG    100    0        0 eth0
10.168.0.1      0.0.0.0         255.255.255.0   U     100    0        0 eth0
172.17.0.0      0.0.0.0         255.255.255.0     U     0      0      0 docker0
```
目标172.17.0.1/24匹配了路由规则三，也就是通过docker0转发。


### 容器如何访问宿主机
首先需要知道容器和宿主机属于不同的网络，容器如何访问宿主机呢？

假设在容器container1上ping 10.168.0.1

1. container1会发现10.168.0.1和自己是不一样的网段，于是匹配了defaut路由规则，也是选择eth0作为数据出口。
2. eth0是成对网络设备，所以eth0发给了插在docker0上另个设备，最终发给了docker0，也就是宿主机器接收到了数据。
3. 宿主机器分析了数据之后，发送目标ip和自己的ip一样，于是就把eth0的MAC地址发送给了container1。

### 宿主机如何访问容器
