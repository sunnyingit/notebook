TCP 协议总结


## 为什么 TCP 建立连接需要三次握手

首先需要明确的是， TCP是可靠性连接，也就说数据在传送的过程中不能丢包，那建立连接为什么需要三次而不是两次呢？

首先连接的第一步是客户端向服务端发起连接请求， 服务端收到请求之后，怎么确定这个请求是新建立请求连接，还是之前未处理的请求数据呢？

这个消息只能有发送端确认，所以三次握手的最后一次客户端向服务端发送ACK来告知服务端，是建立新请求而不是发送之前的数据。

客户端通过解析服务端发送过来的ACK+SYN信息来确定。这才是三次握手的根本原因，因为只有客户端才能知道初始发送的数据是不是要建立链接


TCP 选择使用三次握手来建立连接并在连接引入了 RST 这一控制消息，接收方当收到请求时会将发送方发来的 SEQ+1 发送给对方，这时由发送方来判断当前连接是否是历史连接：

如果当前连接是历史连接，即 SEQ 过期或者超时，那么发送方就会直接发送 RST 控制消息中止这一次连接；
如果当前连接不是历史连接，那么发送方就会发送 ACK 控制消息，通信双方就会成功建立连接；
使用三次握手和 RST 控制消息将是否建立连接的最终控制权交给了发送方，因为只有发送方有足够的上下文来判断当前连接是否是错误的或者过期的，这也是 TCP 使用三次握手建立连接的最主要原因。


## SYN保证可靠性传输

可靠性传输主要是为了解决丢包，乱序的问题，在传送的过程中，有可能网络抖动带来数据帧的丢失，导致一下问题：
1. 数据包被发送方多次发送造成数据的重复；
2. 数据包在传输的过程中被路由或者其他节点丢失；
3. 数据包到达接收方可能无法按照发送顺序；

为了解决上述这些可能存在的问题，TCP 协议要求发送方在数据包中加入『序列号』字段，有了数据包对应的序列号，我们就可以：

接收方可以通过序列号对重复的数据包进行去重；
发送方会在对应数据包未被 ACK 时进行重复发送；
接收方可以根据数据包的序列号对它们进行重新排序；
序列号在 TCP 连接中有着非常重要的作用，初始序列号作为 TCP 连接的一部分也需要在三次握手期间进行初始化，由于 TCP 连接通信的双方都需要获得初始序列号，所以它们其实需要向对方发送 SYN 控制消息并携带自己期望的初始化序列号 SEQ，对方在收到 SYN 消息之后会通过 ACK 控制消息以及 SEQ+1 来进行确认。

## SYN超时

关于建连接时SYN超时。试想一下，如果server端接到了clien发的SYN后回了SYN-ACK后 client掉线了，server端没有收到client回来的ACK，那么，这个连接处于一个中间状态，即没成功，也没失败。于是，server端如果 在一定时间内没有收到的TCP会重发SYN-ACK。在Linux下，默认重试次数为5次，重试的间隔时间从1s开始每次都翻售，5次的重试时间间隔为 1s, 2s, 4s, 8s, 16s，总共31s，第5次发出后还要等32s都知道第5次也超时了，所以，总共需要 1s + 2s + 4s+ 8s+ 16s + 32s = 2^6 -1 = 63s，TCP才会把断开这个连接。

## 重传机制

TCP 传输的可靠性是通过序列号和接收方的 ACK 来保证的，当 TCP 传输一个数据段时，它会将该数据段的副本放到重传队列上并开启计时器：

如果发送方收到了该数据段对应的 ACK 响应，当前数据段就会从重传队列中删除；
如果发送方在计时器到期之间都没有收到该数据段对应的 ACK，就会重新发送当前数据段；

TCP引入了一种叫Fast Retransmit 的算法，不以时间驱动，而以数据驱动重传。也就是说，如果，包没有连续到达，就ack最后那个可能被丢了的包，如果发送方连续收到3次相同的ack，就重传。Fast Retransmit的好处是不用等timeout了再重传。

比如：如果发送方发出了1，2，3，4，5份数据，第一份先到送了，于是就ack回2，结果2因为某些原因没收到，3到达了，于是还是ack回2， 后面的4和5都到了，但是还是ack回2，因为2还是没有收到，于是发送端收到了三个ack=2的确认，知道了2还没有到，于是就马上重转2。然后，接收 端收到了2，此时因为3，4，5都收到了，于是ack回6。

## 拥塞控制

每一个 TCP 连接都会维护一个拥塞控制窗口（Congestion Window），它决定了发送方同时能向接收方发送多少数据，其作用主要有两个：

1. 防止发送方向接收方发送了太多数据，导致接收方无法处理；
2. 防止 TCP 连接的任意一方向网络中发送大量数据，导致网络拥塞崩溃；

除了拥塞窗口大小（cwnd）之外，TCP 连接的双方都有接收窗口大小（rwnd），在 TCP 连接建立之初，发送方和接收方都不清楚对方的接收窗口大小，所以通信双方需要一套动态的估算机制改变数据传输的速度，在 TCP 三次握手期间，通信双方会通过 ACK 消息通知对方自己的接收窗口大小，接收窗口大小一般是带宽延迟乘积（Bandwidth-delay product, BDP）决定的11，不过在这里我们就不展开介绍了。


## TIME_WAIT状态

TCP是全双工的，在关闭连接的时候，发送方和接收方都需要Fin和Ack，具体过程如下：

1. 主动关闭方发送FIN信号给对端，告知对方自己准备关闭连接，这个时候主动关闭方还需要维持连接状态，因为对方可能还有数据还没发送过来，发送消息后会进入 FIN_WAIT_1 状态
2. 被动方收到FIN信号后，会进入 CLOSE_WAIT 状态并向客户端发送 ACK 消息，客户端接收到 ACK 消息时会进入 FIN_WAIT_2 状态；
3. 当被动方没有待发送的数据时，被动方会向主动方发送 FIN 消息；
4. 主动方接收到 FIN 消息后，会进入 TIME_WAIT 状态并向服务端发送 ACK 消息，被动方收到后会进入 CLOSED 状态；

我们会发现 TIME_WAIT 仅在主动断开连接的一方出现，被动断开连接的一方会直接进入 CLOSED 状态，进入 TIME_WAIT 的客户端需要等待 2 MSL 才可以真正关闭连接。


为什么主动关闭方需要维持TIME_WAIT状态，而不是直接进入CLOSED状态呢， 主要是：
1. 防止延迟数据被使用相应协议，相同源地址，源端口，目的地址和目的端口的TCP接收到，导致数据错乱。

我们在数据在网络上传输，可能会延迟，当主动方发送FIN信号后，被动方会发送ACK，并把缓冲区的数据出去，然后发生FIN，如果发生网络抖动，缓冲区的数据可能延迟到达到对端。

一个TCP连接需要[src_port, src_ip, des_port, des_ip, protocol] 5个因子，这5个因子构成一个TCP连接元组。

此时如果建立了新连接(连接元组)，新连接就能接收到之前的数据。为了避免这种情况，所以主动方会进入TIME_WAIT状态，时间是2MSL.

MSL 的时间设置为 120 秒，即两分钟，然而这并不是一个经过严密推断的数值，而是工程上的选择，如果根据服务历史上的经验要求我们改变操作系统的设置，也是没有任何问题的；实际上，较早版本的 Linux 就开始将 TIME_WAIT 的等待时间 TCP_TIMEWAIT_LEN 设置成 60 秒，以便更快地复用 TCP 连接资源。


2. 如果最后主动关闭方发送的ACK丢失，被动关闭方会重传最终那个FIN，以期待主动关闭方重新ACK，所以主动关闭方会维持一个状态，再次ACK最终FIN。

## 常见的TCP flags有哪些
F : FIN - 结束，结束会话
S : SYN - 同步，表示开始会话请求
R : RST - 复位，中断一个连接
P : PUSH - 推送，数据包立即发送
A : ACK - 应答，也用.表示
W : CWR - 拥塞窗口减少
U : URG - 紧急


## 什么是TCP已完成的连接队列和未完成的连接队列

半完成的连接队列(incomplete connection queue): 创建连接时，服务器端接受到客户端发送SYN后，会把SYN放到incomplete connection queue

设置半完成的连接队列配置： tcp_max_syn_backlog

已完成的连接队列 （complete connection queue 创建连接时，如果服务器端接受到了ACK，三次握手完成，说明连接已经建立，则把incomplete connection queue里面的syn移到 complete connection queue里面。

可见如果发送SYN Flood，syns queue里面的syn永远无法移除来(没有接受到客户端的ACK)，所以syns queue会满。

complete connection queue的大小设置在创建监听套接字的时候传递的参数backlog， 设置方法listen(sockFd, backlog)

通常认为backlog = complete connection queue + incomplete connection queue

如果TCP连接队列溢出，有哪些指标可以看呢：
```
[root@server ~]#  netstat -s | egrep "listen|LISTEN"
667399 times the listen queue of a socket overflowed
667399 SYNs to LISTEN sockets ignored

[root@server ~]# ss -lnt
// Send-Q: Send-Q 表示第三列的listen端口上的全连接队列最大为50
Recv-Q Send-Q Local Address:Port  Peer Address:Port
0        50               *:3306             *:*
```


当客户端发送SYN时，如果这些队列是满的，那么服务器端会忽略该分节，也就是说，不发送RST，以期待客户端重新发送SYN （因为队列满状态是暂时的）

服务端调用Accept函数后，会从以完成连接的队列中获取第一个项发回给进程 。如果队列为空，则进程会睡眠


## Socket, Listen, Bind, Accept Close函数分别有什么用
Socket: 创建一个TCP或者UDP套接字 socket(family, type, protocol) family: AF_INET, AF_INET6, protocol:SOCK_STREAM, SOCK_DGRAM
Listen: 把一个套接字变成监听套接字，在服务器的生命周期内都不能关闭这个套接字
Accept: 返回一个已经连接的套接字
Connect: 连接对方服务器，发起三次握手，参数有(socketfd, addr, port) 必须传递服务器的端口号和ip地址，client没有收到SYN的响应(ACK), 则会重传这个分节，若75s后还是没有收到ACK应答这返回ETIMEDOUT错误,client收到的是RST应答，则表示服务器没有启动或者连接端口错误
Close: 值得注意的是close也许不会立即触发4次握手，在多进程的TCP服务器中，父进程会关闭已经连接的套接字，只是把套接字的引用计数减1，第二点，调用close之后，这个套接字不能再被进程使用，也就是不能作为read或write的参数，但是TCP将会已经排队等待发送给对端的数据发送完了之后，才会发生正常的TCP终止序列


## 套接字的接受缓冲区和发送缓冲区
每个TCP套接字都有一个发送缓冲区，我们可以使用SO_SENDBUF 套接字选项来改变套接字缓冲区的大小。

当应用程序在阻塞的套接字上调用write或者send函数时，如果要发送的数据大于目前发送缓冲区的大小，则程序挂起。

如果有足够的空间保存应用程序的数据，则write返回成功，但这并不代表数据已经发送成功，只是说明数据写入到发送缓冲区成功。

发送端的TCP会提取套接字发送缓冲区的数据并发给另一端，只有当另一端的TCP 确认接收到数据后，发送端才会清空发送缓冲区的数据。

对于UDP套接字而言，没有发送缓冲区。

每个套接字(包括UDP)都有一个接收缓冲区。三次握手完成后，数据发送过来，首先会写入到接收缓冲区里面, 相关配置:

SO_RCVBUF: 接受缓冲区的大小 (int)
SO_SNDBUF: 发送缓冲区的大小 (int)
SO_RCVLOWAT: 接受缓冲区的低水位大小 (int=1)
SO_SNDLOWAT: 发送缓冲区的低水位 (int=2048)


## SO_KEEPALIVE

连接上双方任意方向在2小时之内没有发送过数据，那么tcp会自动发送一个探测探测包给对方，这种探测包对方是必须回应的，回应结果有三种：

1.正常ack，继续保持连接；

2.对方响应rst信号，双方重新连接。

3.对方无响应。

这里说的2小时，其实是依赖于系统配置，在linux系统中（windows在注册表中，可以自行查询资料），tcp的keepalive参数

net.ipv4.tcp_keepalive_intvl = 75 （发送探测包的周期，前提是当前连接一直没有数据交互，才会以该频率进行发送探测包，如果中途有数据交互，则会重新计时tcp_keepalive_time，到达规定时间没有数据交互，才会重新以该频率发送探测包）
net.ipv4.tcp_keepalive_probes = 9  （探测失败的重试次数，发送探测包达次数限制对方依旧没有回应，则关闭自己这端的连接）
net.ipv4.tcp_keepalive_time = 7200 （空闲多长时间，则发送探测包）

一般应用程序会通过检测进程的端口号和进程PID来判断进程是否存在。
