分布式事务的理解

## 概述

在分布式系统中，为了保证数据的高可用，通常，我们会将数据保留多个副本(replica)，这些副本会放置在不同的物理的机器上。为了对用户提供正确的增\删\改\查等语义，我们需要保证这些放置在不同物理机器上的副本是一致的。



为了解决这种分布式一致性问题，前人在性能和数据一致性的反反复复权衡过程中总结了许多典型的协议和算法。其中比较著名的有二阶提交协议（Two Phase Commitment Protocol）、三阶提交协议（Three Phase Commitment Protocol）和Paxos算法。



## 分布式事务

分布式事务是指会涉及到操作多个数据库的事务。
其实就是将对同一库事务的概念扩大到了对多个库的事务。目的是为了保证分布式系统中的数据一致性。分布式事务处理的关键是必须有一种方法可以知道事务在任何地方所做的所有动作，提交或回滚事务的决定必须产生统一的结果（全部提交或全部回滚）
在分布式系统中，各个节点之间在物理上相互独立，通过网络进行沟通和协调。

由于存在事务机制，可以保证每个独立节点上的数据操作可以满足ACID。但是，相互独立的节点之间无法准确的知道其他节点中的事务执行情况。所以从理论上讲，两台机器理论上无法达到一致的状态。

如果想让分布式部署的多台机器中的数据保持一致性，那么就要保证在所有节点的数据写操作，要么全部都执行，要么全部的都不执行。但是，一台机器在执行本地事务的时候无法知道其他机器中的本地事务的执行结果。所以他也就不知道本次事务到底应该commit还是
roolback。所以，常规的解决办法就是引入一个“协调者”的组件来统一调度所有分布式节点的执行。


## 2PC-二阶段提交协议

2PC的两个阶段是：
1. Vote 投票阶段
2. Commit 提交阶段

主要过程是：
1. 事务协调者会给每个参与的节点发送请求，询问是否可以提交事务
2. 参与者收到请求后，会做一下准备工作，比如给资源上锁，写redo undo log等，如果可以提交，则响应Yes否则响应No
3. 如果协调者收到有参与者响应为No，或者因为网络请求超时，则直接给每个参与者发送回滚(Rollback)消息
4. 如果协调者收到所有参与者的响应都为Yes，则发生消息告诉参与者可以Commit
5. 提交阶段，如果参与者接受到的信息是rollback或者因为超时没有收到信息，则回滚并释放资源
6. 如果参与接受到了commit消息，则提交事务并释放资源。

2PC的主要问题如下：
1. 在vote阶段就对数据加锁保护，其他第三方节点访问公共资源不得不处于阻塞状态。
2. 单点故障。由于协调者的重要性，一旦协调者发生故障。参与者会一直阻塞下去。
3. 数据不一致，在提交阶段，可能有的参与者收到了commit指令，提交事务成功，有的没有收到指令提交失败，导致数据不一致
4. 事务不确定性，协调者再发出commit消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。


## 3PC-三阶段提交
3PC对比2PC主要增加了`CanCommit`阶段：
1. `CanCommit`阶段：协调者向参与者发送CanCommit请求。询问是否可以执行事务提交操作。然后开始等待参与者的响应。
2. 参与者接到CanCommit请求之后，正常情况下，如果其自身认为可以顺利执行事务，则返回Yes响应，并进入预备状态，此时不会对资源进行上锁。
3. `PreCommit`阶段：参与者接收到PreCommit请求后，会执行事务操作，并将undo和redo信息记录到事务日志中。
4. `doCommit`阶段：提交阶段。


## 2PC与3PC的区别

1. 询问阶段是不会对资源进行加锁，提升系统的并发性。
设有1个协调者，9个参与者。其中有一个参与者不具备执行该事务的能力。
协调者发出prepare消息之后，其余参与者都将资源锁住，执行事务，写入undo和redo日志。
协调者收到相应之后，发现有一个参与者不能参与。所以，又出一个roolback消息。其余8个参与者，又对消息进行回滚。这样子，是不是做了很多无用功？
所以，引入can-Commit阶段，主要是为了在预执行之前，保证所有参与者都具备可执行条件，从而减少资源浪费。

2. 如果协调者在发出PreCommit信息后crash了，参与者会主动提交。
在doCommit阶段，如果参与者无法及时接收到来自协调者的doCommit或者rebort请求时，会在等待超时之后，会继续进行事务的提交。


3PC也和2PC一样，存在数据不一致的问题。

## Paxos算法
Paxos算法解决的问题正是分布式一致性问题，即一个分布式系统中的各个进程如何就某个值（决议）达成一致。

一个或多个提议进程 (Proposer) 可以发起提案 (Proposal)，Paxos算法使所有提案中的某一个提案，在所有进程中达成一致。系统中的多数派同时认可该提案，即达成了一致。
最多只针对一个确定的提案达成一致。


Paxos将系统中的角色分为提议者 (Proposer)，决策者 (Acceptor)，和最终决策学习者 (Learner):
1. Proposer: 提出提案 (Proposal)。Proposal信息包括提案编号 (Proposal ID) 和提议的值 (Value)。
2. Acceptor：参与决策，回应Proposers的提案。收到Proposal后可以接受提案，若Proposal获得多数Acceptors的接受，则称该Proposal被批准。
3. Learner：不参与决策，从Proposers/Acceptors学习最新达成一致的提案（Value）。

在多副本状态机中，每个副本同时具有Proposer、Acceptor、Learner三种角色。

Paxos算法推导:![Paxos](https://www.cnblogs.com/linbingdong/p/6253479.html)
