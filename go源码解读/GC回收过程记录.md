GC回收过程记录


## 标记-清除法（mark and sweep）
原始的标记清楚法分为两个步骤：
1. Mark 标记。先STP(Stop The World)，暂停整个程序的全部运行线程，将被引用的对象打上标记
2. Sweep 清除没有被打标机的对象。

这样做有个很大的问题就是要通过STW保证GC期间标记对象的状态不能变化，整个程序都要暂停掉，在外部看来程序就会卡顿。


## 三色标记法
三色标记法是对标记阶段的改进，原理如下：

1. 初始状态所有对象都是白色。
2. 从root根出发扫描所有根对象，将他们引用的对象标记为灰色
3. 如果有引用则将它变为黑色的同时将它引用的对象也变为灰色
4. 直到灰色对象队列为空。此时白色对象即为垃圾，进行回收。

那么什么是root呢？
GC回收都是全局对象和堆的数据，所以root包括全局对象和堆数据，此外还包括所有协程的栈变量，因为栈遍历可能引用了堆的数据，所以需要扫描。



## 具体步骤

1. Mark Prepare: 初始化GC任务，包括开启写屏障(write barrier)和辅助GC(mutator assist)，统计root对象的任务数量等。这个过程需要STW
2. GC Drains: 扫描所有root对象，包括全局指针和goroutine(G)栈上的指针（扫描对应G栈时需停止该G)，将其加入标记队列(灰色队列)，并循环处理灰色队列的对象，直到灰色队列为空，为了提速，这个过程可以多并发做。
3. Mark Termination: 完成标记工作，重新扫描(re-scan)全局指针和栈。因为Mark和用户程序是并行的，所以在Mark过程中可能会有新的对象分配和指针赋值，这个时候就需要通过写屏障（write barrier）记录下来，re-scan 再检查一下，这个过程也是会STW的。
4. Sweep: 按照标记结果回收所有的白色对象，该过程后台并行执行，这个过程并不需要STW。
5. Sweep Termination: 对未清扫的span进行清扫, 只有上一轮的GC的清扫工作完成才可以开始新一轮的GC。


如果标记期间用户逻辑改变了刚打完标记的对象的引用状态，怎么办呢？

## 写屏障(Write Barrier)
写屏障：该屏障之前的写操作和之后的写操作相比，先被系统其它组件感知。
好难懂哦，结合上面GC工作的完整流程就好理解了，就是在每一轮GC开始时会初始化一个叫做“屏障”的东西，然后由它记录第一次scan时各个对象的状态，以便和第二次re-scan进行比对，引用状态变化的对象被标记为灰色以防止丢失，将屏障前后状态未变化对象继续处理。
