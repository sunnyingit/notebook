


阅读本文将收获：

、、、
理解GMP模型和多线程模型相比的优势
理解协程调度的时机
理解逻辑处理器P选取协程的策略
理解如何处理协程长期霸占线程 (比如死循环)
深刻理解系统调用，CPU上下文切换等基础知识
、、、

## GMP模型

在`协程执行`这篇文章中，我们分享了Go协程的运行，其中涉及到GMP模型，这里再次复习一下：

、、、
G: Goroutine, 表示go协程
M: Manager, 表示操作系统的线程
P: Processor, 表示逻辑处理器
、、、

除此之外，还有一个组件叫做`调度器`，协程的执行流程：`调度器通过逻辑处理器P选择一个合适的协程G在线程上M运行`。

协程运行具体的过程如下：

 1. 线程启动，运行协程g0
 2. 协程g0执行调度函数，选择合适的协程G1
 3. 将新协程G1绑定到线程上，执行新协程G1
 4. 触发调度，G1与线程解绑，线程再次与g0绑定
 5. 协程g0执行调度函数，选择合适的协程G2, 然后重复3，4步骤


所谓协程调度，就是线程并发的执行多个协程。这个过程看似简单，其实这里有5个问题，需要我们刨根问底：


- GMP模型和多线程模型相比，有什么优势
- 协程调度的时机
- 逻辑处理器P选取协程的策略
- 如何处理协程长期霸占线程 (比如死循环)
- 目前协程的调度有什么问题


我们把这5个问题搞清楚了，基本上就理解了协程调度。

老规矩，一个一个来。

## 【GMP】VS【多线程】
 > 背景：一个有10 core CPU的机器，需要处理1K个并发请求。

【多线程】方案是`创建1k的线程，每个线程处理一个请求`。

1. 每个线程大概使用1M左右内存，1K个线程大约使用1G左右
2. 10 core 的CPU运行1000个线程，每个core负责调度100个线程，这会导致频繁的CPU上下文切换
3. 当线程执行阻塞调用时，会导致线程阻塞

【GMP】方案是 `创建10个线程, 创建1k协程，每个线程调度100个协程, 每个协程处理一个请求`。


1. 每个协程大概使用2KB左右，1k个协程大概使用2M左右内存，加上10个线程使用的内存，最终使用内存大概是12M左右
2. 创建10个线程，也就是线程数等于CPU核数，1个核执行1个线程，基本上不会导致CPU上下文切换
3. 协程在处理阻塞式系统调用时，不会粗暴的导致线程阻塞


对比看来，GMP模型使用`更少的内存，更少的线程`得到`更高效并发处理方式`。


下面，我们具体分析一下协程的调度。

## 线程调度

协程的调度和线程的调度非常类似，我们不妨先讲一讲线程的调度。

所谓`线程调度`, 就是操作系统把当前正在CPU运行的线程切换出去，然后选择另一个可运行的线程运行。

作为开发者，我们关心的线程调度的时机有:

、、、
1. 线程时间片到期
2. 系统调用
、、、

## 线程时间片到期

操作系统会把时间分配给线程，线程占有的CPU时间到期后，就会被CPU切换出去。
所以，创建的线程越多，单个线程所占用的CPU时间就越少，线程调度会更频繁。


## 系统调用

>`阻塞式的系统调用`会导致当前线程挂起，触发线程调度, 当前线程的状态由运行态变为阻塞态。

要理解这句话，必须清楚什么是`系统调用`。

要理解`系统调用`，我们必须清楚一个概念：`内核态和用户态`。

操作系统分为`用户空间和内核空间`，线程在用户空间运行时，被称为线程的`用户态`，而陷入内核空间的时候，被称为线程的`内核态`。

`用户态`到`内核态`的转变，需要通过`系统调用`来完成，`系统调用`就是`调用系统内核函数`。

比如，我们调用`open`函数打开一个文件，`open`是内核函数，这个过程会发生CPU上下文切换:

1. 保存CPU寄存器现场
2. CPU寄存器更新为内核态指令
3. CPU执行内核态运行内核任务
4. 当系统调用结束后，CPU寄存器需要恢复原来保存的用户态，然后再切换到用户空间，继续运行线程。


所以一次系统调用的过程，其实是发生了两次 CPU 上下文切换： `用户态-内核态-用户态`。

除了`open`函数外，我们常见的内核函数还包括所有的`IO函数`, 如 `read, write, select, epoll`等。

当我们`阻塞式`的调用`read, write`等内核函数时，会导致线程阻塞，从而触发线程调度，将阻塞的线程切换出去，CPU从`内核态`切换到`用户态`后，会运行一个新的线程。

但是，`非阻塞式的系统调用`只会导致CPU上下文切换，不会导致线程阻塞，当系统调用完成后，还会继续运行之前线程。

总结一下，`系统调用`一定会导致`CPU上下文切换`，但是不一定导致`线程调度`，只有阻塞式的系统调用才会导致线程调度。

因为线程调度的存在，线程状态被分为：运行态，就绪态，阻塞态，关于线程状态就不再多讲了。

*我们在编程过程中，应该避免频繁的线程调度，为什么呢？*

因为线程调度一定会导致CPU上下文切换，如果CPU上下文切换频繁，意味着CPU花在用户线程的时间就越少，CPU的利用率就越低。

所以，我们不能创建大量的线程，除了内存限制外，更重要的是CPU的性能方面的考虑。

而协程设计的宗旨之一，就是减少不必要的CPU上下文切换。

下面，我们来看看协程是如何实现这一宗旨的。

## 协程调度

在了解协程调度机制之前，一定要有一个概念：`线程的调度是由操作系统完成的，协程的调度是由线程完成的`。

换句话说，线程的调度在内核态完成，有CPU上下文切换的开销，而协程的调度是在用户空间完成，并没有CPU上下文切换的开销。

但是，协程在执行系统调用时，还是会导致CPU上下文切换，要正确理解`协程调度`和`协程执行`是两个不同的阶段。

触发协程的调度有几种情况：

1. 创建协程
2. 系统调用, 分为阻塞和非阻塞两种方式
3. 同步操作，例如加锁，channel等操作
4. 协程主动让出线程执行权
5. GC


这里，我们重点讨论一下`创建协程`，`系统调用`，`同步操作`对协程调度的影响。

## 创建协程

在GMP模型中，一个线程M对应一个处理器P, 每个处理P持有一个协程本地协程队列`LRQ [Local Run Queue]`。

`LRQ`队列是一个使用数组构成的环形链表，它最多可以存储 `256`个协程。

同时，还存在一个全局协程队列`GRQ [Global Run Queue]`，所有的线程都可以从这个队列里面获取协程。


当我们创建一个新协程后，协程可能添加到`LRQ`, 也有可能添加到`GRQ`, 具体策略是：

1. 如果LRQ满了，则添加到GRQ
2. 如果LRQ没有满，则有一定几率作为处理器P下次选择的协程，否则直接添加到LRQ尾部


添加协程到队列的伪代码如下：

、、、
func runqput(_p_ *p, gp *g, next bool) {
	if randomizeScheduler && next && fastrand()%2 == 0 {
		next = false
	}

    // next=true，表示线程下次就会执行gp
	if next {
	    // 作为下一个被执行的g
	    _p_.runnext = gp
	} else {
	    if (is_full()) {
	        // 插入到全局队列尾部
	        G.runq.tail = gp
	    } else {
	        // 插入到本地队列尾部
	        g.runq.tail = gp
	    }
	}
}
、、、

从队列中获取协程策略：

1. 优先查找全局运行，有一定几率查找到；
2. 查找全局队列失败，则从处理器本地的运行队列中查找；
3. 查找本地队列失败，则通过findrunnable进行阻塞地查找，直到找到位置


伪代码如下：
、、、
func schedule() {
	if gp == nil && gcBlackenEnabled != 0 {
		gp = gcController.findRunnableGCWorker(_g_.m.p.ptr())
		tryWakeP = tryWakeP || gp != nil
	}

	if gp == nil {
        // 有一定的概率从全局队列获取，全局队列获取一定要加锁
		if _g_.m.p.ptr().schedtick%61 == 0 && sched.runqsize > 0 {
			lock(&sched.lock)
			gp = globrunqget(_g_.m.p.ptr(), 1)
			unlock(&sched.lock)
		}
	}
	// 全局队列获取失败，则从本地获取
	if gp == nil {
		gp, inheritTime = runqget(_g_.m.p.ptr())
	}

	// 本地获取失败，则调用findrunnable阻塞式的获取，这个函数一定会获取到协程
	if gp == nil {
	   // blocks until work is available
		gp, inheritTime = findrunnable()
	}
}
、、、


## 系统调用-阻塞调用

阻塞式的系统调用会导致线程阻塞，如果线程M阻塞，意味着线程M对应处理器P上的所有G都无法运行。

那就失去了并发的可能性。

Go是不会允许这种事情发生的，一旦出现这种情况，Go会把将线程M和处理器P分离，同时创建一个新的线程继续处理P上面的协程。

当协程完成阻塞调用后，G会移动到其他线程的处理器P上, 等待下次处理。


## 系统调用-非阻塞调用

在linux系统中，我们可以使用 `setblocking epoll, select`等函数实现`异步非阻塞的IO调用`。

通过这种机制，一旦协程发起IO调用，线程会把协程切换出去，切换出去的协程阻塞在`epoll`上，当前线程M会继续服务处理器P队列。

当阻塞的IO准备好后，对应的协程会再次加入到P队列中。

类似的情况还有`select`函数等。

## 同步操作

If an atomic, mutex, or channel operation call will cause the Goroutine to block, the scheduler can context-switch a new Goroutine to run. Once the Goroutine can run again, it can be re-queued and eventually context-switched back on an M.



## Work Stealing

`Work Stealing` 是指当`LRQ`没有协程之后，线程可能从其他线程的协程队列中偷取协程。

每次会偷取其他线程队列中一半的协程。

这种做法是为了提高协程的并发处理能力。

## 抢占式调度

试想一下，如果协程是执行一个死循环，那它将永远霸占线程，其他的协程将没有机会得到运行，这种情况是不允许发生的。

抢占式调度，就是处理这种情况。

如果发现某个协程执行时间超过了10ms, 则剥夺其线程的控制权。大概的原理：
1. 协程有一个属性是`stackguard0`, 用于判断是否需要被剥夺执行权。
2. Go会监控协程的执行时间，如果超过10ms, 则设置`stackguard0=StackPreempt`
3. 当协程发生函数调用时，会检测协程`stackguard0 == StackPreempt`， 如果相等，则当前协程让出控制权。


## 协程状态

和线程一样，主要的协程状态有：

1. runnable	存储在运行队列中
2. running	可以执行代码，拥有线程的执行所有权
3. syscall	正在执行系统调用
4. waiting	由于运行时而被阻塞
5. preempted 由于抢占而被阻塞，等待唤醒

协程状态和线程状态类似，但是多了一些状态，Go之所以抽象出`syscall`, `waiting`, `preempted`这些状态，是因为这些状态对应特殊的处理方式。

具体的处理方式，上文已经给出答案。


## 协程的思考

>问题1： Go的协程调度机制子所以能顺利运行，在于Go能`预知`协程的指令，在执行系统调用之前做一些准备工作。Go是如何预知指令的呢？

答案： Go语言通过`syscall.Syscall` 和 `syscall.RawSyscall` 等使用汇编语言编写的方法封装了操作系统提供的所有系统调用，正是这一层包装能够让go在陷入系统调用前触发运行时的准备和清理工作。

>问题2：10个线程同时只能处理10个协程，10个协程处理10个请求，那其他990个请求是不是都等着？

答案：是的，其他线程确实只有等着，直到占用CPU的协程让出控制权，才有可能被调度到，那种这种效率高不高呢，要分情况来看：

- 如果请求是`CPU密集型`，这种情况，更好的方案是创建更多的线程来运行。
- 如果请求是`IO密集型`，这种情况，协程主要的耗时在等待IO完成，当协程在等待IO的时候，线程会把当前协程切换出去，线程会接运行队列中的其它写协程，所以Go适合大部分的`IO密集型`高并发场景。


>问题3： 协程和线程相比，有什么不同和劣势？

答案：先线程不同的是，协程没有父子关系，劣势的话，协程没有优先级概念，所有的协程都是平等的, 协程出队列采用FIFO的方式，比较死板。

> 问题4：协程执行完成后，会怎么样

答案： 协程执行完成后，会被重置，然后添加到处理器P空闲队列`gfree`中,下次再创建协程时，首先从`gfree`列表中找到闲置的协程，如果找不到，才会重新分配内存，创建协程对象。

这种做法避免了内存分配的压力。

如果因为一些特殊原因，比如死锁，channel阻塞等，导致协程无法释放，这种情况被称为协程泄露，在使用协程时，推荐加入协程超时处理，防止协程泄露。

## 总结

再次梳理一下本文重点：
1. go程序启动时，默认启动最大线程数是当前机器CPU的核数
2. go最大的线程活跃数由GOMAXPROCS决定，最大的线程数是sched.maxmcount = 10000
2. 一个线程可以并发的执行多个协程
3. 线程使用内存大概是2M，协程使用内存大概是2K，当协程栈内存不够时，会自动扩容
4. go会更优雅的处理`系统调用`，`同步操作`等，保证并发性。
